# Medical Lock Hospitals Data Explorer
# Shiny App for data exploration and cleaning

library(shiny)
library(DBI)
library(RSQLite)
library(DT)
library(plotly)
library(dplyr)
library(ggplot2)
library(shinyWidgets)
library(shinydashboard)
library(leaflet)
library(tidyr)
library(stringr)
library(networkD3)
library(sf)  # For reading shapefiles
library(rnaturalearth)  # For country boundaries
library(rnaturalearthdata)  # Country boundary data
## Optional: Excel ingestion for DS_Dataset (used if available)
# We'll use readxl lazily via requireNamespace in server to avoid hard dependency at load time.

# Suppress R CMD check warnings for dplyr NSE variables
utils::globalVariables(c(
  "total_added", "total_removed", "total_registered", "has_data", "name", "pk", "type",
  "year", "station_key", "station", "region", "country", "male_mentions", "female_mentions",
  "total_mentions", "text_blob", "__sheet__", "ops_inspection_regularity",
  "ops_unlicensed_control_notes", "ops_committee_activity_notes", "remarks", "freq",
  "fined_count", "imprisonment_count", "disease_primary_syphilis", "disease_secondary_syphilis",
  "disease_gonorrhoea", "disease_leucorrhoea", "marker_color", "marker_opacity", "radius",
  "longitude", "latitude", "act", "avg_strength", "vd_primary_admissions", "vd_secondary_admissions",
  "vd_other_admissions", "total_vd_cases", "doc_id", "hid", "sid", "Year", "Section"
))

# Ensure images directory exists and serve as /images
if (!dir.exists("content/images")) {
  dir.create("content/images", recursive = TRUE, showWarnings = FALSE)
}
# Create a sanitized copy of images to avoid spaces/unicode in filenames which can
# cause browser-loading issues. Serve the sanitized directory as the /images resource.
img_src_dir <- "content/images"
img_safe_dir <- "content/images_safe"
if (!dir.exists(img_safe_dir)) dir.create(img_safe_dir, recursive = TRUE, showWarnings = FALSE)

sanitize_name <- function(fn) {
  ext <- tools::file_ext(fn)
  base <- tools::file_path_sans_ext(fn)
  # transliterate to ASCII, replace non-alphanumerics with underscore
  base2 <- iconv(base, to = "ASCII//TRANSLIT", sub = "")
  base2 <- gsub("[^A-Za-z0-9._-]", "_", base2)
  base2 <- gsub("_+", "_", base2)
  newn <- if (nzchar(ext)) paste0(base2, ".", tolower(ext)) else base2
  newn
}

src_files <- list.files(img_src_dir, full.names = FALSE)
for (f in src_files) {
  src <- file.path(img_src_dir, f)
  # Skip if source is a directory
  if (dir.exists(src)) next
  dst <- file.path(img_safe_dir, sanitize_name(f))
  if (!file.exists(dst)) {
    tryCatch(file.copy(src, dst), error = function(e) message("Failed to copy image: ", f, " -> ", e$message))
  }
}
shiny::addResourcePath("images", img_safe_dir)

# Database connection function
connect_to_db <- function() {
  db_path <- "medical_lock_hospitals.db"
  if (!file.exists(db_path)) {
    stop("Database file not found. Please ensure medical_lock_hospitals.db is in the working directory.")
  }
  dbConnect(RSQLite::SQLite(), db_path)
}

# UI
ui <- dashboardPage(
  dashboardHeader(title = "Governing Diseases and Sexuality in Colonial India"),
  
  dashboardSidebar(
    sidebarMenu(id = "sidebar",
      menuItem("Story", tabName = "story", icon = icon("book-open")),
      menuItem("Interactive Map", tabName = "map", icon = icon("map")),
      menuItem("Data Tables", tabName = "tables", icon = icon("table")),
      menuItem("Data Cleaning", tabName = "cleaning", icon = icon("broom")),
      menuItem("Hospital Notes", tabName = "hospital_notes", icon = icon("clipboard")),
      menuItem("Data Export", tabName = "export", icon = icon("download"))
    )
  ),
  
  dashboardBody(
    tags$head(
      tags$style(HTML("
        .content-wrapper, .right-side {
          background-color: #f4f4f4;
        }
        .box {
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        /* Hide Shiny busy overlay and modal backdrop to avoid dimming during long renders (temporary) */
        .shiny-busy, .shiny-busy-indicator, .shiny-busy-overlay, .shiny-busy-container { display: none !important; visibility: hidden !important; }
        .modal-backdrop { display: none !important; }
      "))
    ),
    
    tabItems(
      # Story Tab - Scrollytelling Narrative (combined with Data Overview)
      tabItem(tabName = "story",
        tags$head(
          tags$style(HTML("
            .story-section {
              min-height: 100vh;
              padding: 60px 20px;
              display: flex;
              align-items: center;
              border-bottom: 1px solid #e0e0e0;
            }
            .story-content {
              max-width: 900px;
              margin: 0 auto;
            }
            .story-title {
              font-size: 2.5em;
              font-weight: 300;
              margin-bottom: 20px;
              color: #2c3e50;
            }
            .story-text {
              font-size: 1.2em;
              line-height: 1.8;
              color: #34495e;
              margin-bottom: 30px;
            }
            .story-stat {
              font-size: 3em;
              font-weight: bold;
              color: #e74c3c;
              margin: 20px 0;
            }
            .story-caption {
              font-size: 0.9em;
              color: #7f8c8d;
              font-style: italic;
            }
            .viz-container {
              margin: 40px 0;
              background: white;
              padding: 20px;
              border-radius: 8px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }
          "))
        ),
        
        # Section 1: Introduction - About the Dataset
        div(class = "story-section", style = "background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;",
          div(class = "story-content",
            h1(class = "story-title", style = "color: white;", "Governing Diseases and Sexuality in Colonial India"),
            p(class = "story-text", style = "color: rgba(255,255,255,0.95);",
              "This dataset is built from nineteenth-century Lock Hospital Reports and Sanitary Commissioner's Reports produced under British rule in India. These records were part of a larger administrative effort to monitor women categorized as \"registered prostitutes\" under the Contagious Diseases Acts. Through these reports, the colonial state sought to control the spread of venereal disease among soldiers by transforming women's bodies into objects of record and inspection."
            ),
            p(class = "story-text", style = "color: rgba(255,255,255,0.95);",
              "The figures in these documents (women admitted, discharged, fined or imprisoned, soldiers treated for disease, hospital openings and closures) show how public health became a language of governance. Medical management was tightly bound to moral discipline and imperial control."
            ),
            p(class = "story-text", style = "color: rgba(255,255,255,0.95);",
              "Each entry in this dataset reflects the bureaucratic structure of the colonial state: the staffing of hospitals, the geography of cantonments, and the regular counting of \"registered\" and \"unregistered\" women. Taken together, these numbers allow us to see how the colonial government converted everyday life into data, turning acts of care into mechanisms of surveillance."
            ),
            p(class = "story-text", style = "color: rgba(255,255,255,0.95);",
              "Rather than treating these figures as neutral statistics, this project reads them as evidence of how medicine, morality, and governance became intertwined in the making of empire."
            )
          )
        ),
        
        # Section 2: The Scale - Database Summary
        div(class = "story-section",
          div(class = "story-content",
            h2(class = "story-title", "A System Across an Empire"),
            p(class = "story-text",
              "Lock Hospitals operated across British India, from Bengal to Burma, creating a vast infrastructure of medical control. Each station became a site where military necessity intersected with moral regulation."
            ),
            div(class = "viz-container",
              uiOutput("story_total_stats")
            ),
            div(class = "viz-container",
              div(style = "margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 4px;",
                h4("Filter Stations by Contagious Diseases Acts", style = "margin-top: 0; margin-bottom: 12px; color: #2c3e50; font-size: 16px;"),
                checkboxGroupInput("story_map_acts_filter",
                  label = NULL,
                  choices = c(
                    "Act XXII of 1864 / Cantonment Act 1864" = "1864",
                    "Act XIV of 1868 / Contagious Diseases Act 1868" = "1868",
                    "Act III of 1880 / Cantonment Act 1880" = "1880",
                    "Cantonment Act 1889" = "1889",
                    "Voluntary System" = "voluntary",
                    "No Act / Unknown" = "none"
                  ),
                  selected = c("1864", "1868", "1880", "1889", "voluntary", "none"),
                  inline = FALSE
                )
              ),
              leafletOutput("story_map_overview", height = 500)
            ),
            br(),
            div(class = "viz-container",
              h4("Data Quality Summary", style = "margin-bottom: 20px; color: #2c3e50;"),
              DT::dataTableOutput("quality_summary")
            )
          )
        ),
        
        # Section 3: From the Archives - Images
        div(class = "story-section", style = "background: #f8f9fa;",
          div(class = "story-content",
            h2(class = "story-title", "From the Archives"),
            p(class = "story-text",
              "These selections from nineteenth-century reports and illustrations offer a glimpse into the visual culture of colonial medical surveillance. Each document reflects how the state rendered women's bodies as objects of study and control."
            ),
            div(class = "viz-container",
              fileInput("archive_image_upload", "Upload images (JPG/PNG/WebP)", multiple = TRUE,
                        accept = c("image/png","image/jpeg","image/webp","image/gif")),
              helpText("You can also place files directly in content/images/."),
              uiOutput("overview_images")
            )
          )
        ),
        
        # Section 4: The Timeline - Acts of Empire
        div(class = "story-section",
          div(class = "story-content",
            h2(class = "story-title", "Acts of Empire"),
            p(class = "story-text",
              "Three major Acts structured this system of control:"
            ),
            div(class = "viz-container",
              htmlOutput("story_acts_timeline")
            ),
            p(class = "story-text",
              "Each Act expanded the state's power to inspect, register, and punish women suspected of spreading disease."
            )
          )
        ),
        
        # Section 5: Conclusion - Reading the Archive
        div(class = "story-section", style = "background: #2c3e50; color: white; min-height: 80vh;",
          div(class = "story-content",
            h2(class = "story-title", style = "color: white;", "Reading the Archive"),
            p(class = "story-text", style = "color: rgba(255,255,255,0.95);",
              "These numbers—women registered, fined, examined—were never neutral. They represent acts of violence made routine through bureaucracy."
            ),
            p(class = "story-text", style = "color: rgba(255,255,255,0.95);",
              "By reading these records critically, we can see how colonial medicine became a tool of empire, and how women's bodies became sites of state control."
            ),
            br(), br(),
            actionButton("explore_data_btn", "Explore the Full Dataset", 
                        class = "btn-lg btn-primary",
                        style = "padding: 15px 40px; font-size: 1.2em;",
                        onclick = "Shiny.setInputValue('switch_to_tables', Math.random())")
          )
        )
      ),
      
      # Interactive Map Tab
      tabItem(tabName = "map",
        fluidRow(
          column(3,
            # Sidebar controls
            wellPanel(
              style = "background: white; padding: 20px;",
              
              h4("Lock Hospital Locations and Railway Expansion (1873–1890)", 
                 style = "margin-top: 0; font-weight: bold;"),
              
              hr(),
              
              # Single-year slider
              sliderInput("year_slider", "Select Year:",
                min = 1873, max = 1890,
                value = 1873,
                step = 1,
                sep = "",
                animate = animationOptions(interval = 1500, loop = FALSE)
              ),
              
              hr(),
              
              # Layer toggles
              h5("Map Layers", style = "font-weight: bold; margin-bottom: 10px;"),
              checkboxInput("show_railways", "Railway Lines & Stations", value = TRUE),

              hr(),
              
              hr(),
              
              # Legend
              h5("Legend", style = "font-weight: bold; margin-bottom: 10px;"),
              htmlOutput("map_legend")
            )
          ),
          column(9,
            # Map display
            box(
              title = NULL,
              status = "primary",
              solidHeader = FALSE,
              width = 12,
              height = "750px",
              leafletOutput("map", height = "700px")
            )
          )
        ),
        # Data tables for map data
        fluidRow(
          box(
            title = "Lock Hospital Admission Data",
            status = "primary",
            solidHeader = TRUE,
            width = 12,
            collapsible = TRUE,
            DT::dataTableOutput("map_data_table")
          )
        ),
        fluidRow(
          column(6,
            box(
              title = "Railway Lines in Operation",
              status = "info",
              solidHeader = TRUE,
              width = 12,
              collapsible = TRUE,
              collapsed = TRUE,
              DT::dataTableOutput("railway_lines_table")
            )
          ),
          column(6,
            box(
              title = "Railway Stations",
              status = "info",
              solidHeader = TRUE,
              width = 12,
              collapsible = TRUE,
              collapsed = TRUE,
              DT::dataTableOutput("railway_stations_table")
            )
          )
        )
      ),
      
      # Data Tables Tab
      tabItem(tabName = "tables",
        fluidRow(
          box(
            title = "Select Table to View & Edit", status = "primary", solidHeader = TRUE,
            width = 12,
            fluidRow(
              column(6,
                selectInput("table_select", "Choose Table:",
                  choices = c("documents", "stations", "station_reports", 
                             "women_admission", "troops", "hospital_operations"),
                  selected = "documents"
                )
              ),
              column(6,
                div(style = "margin-top: 25px;",
                  actionButton("delete_row_btn", "Delete Selected Row", icon = icon("trash"), class = "btn-danger"),
                  actionButton("add_row_btn", "Add New Row", icon = icon("plus"), class = "btn-success")
                )
              )
            ),
            br(),
            helpText("Click any cell to edit. Changes save automatically. Select a row and click 'Delete' to remove it."),
            DT::dataTableOutput("data_table")
          )
        )
      ),
      
      # Data Cleaning Tab
      tabItem(tabName = "cleaning",
        fluidRow(
          box(
            title = "Data Cleaning Tools", status = "success", solidHeader = TRUE,
            width = 12,
            tabsetPanel(
              tabPanel("Duplicate Detection",
                br(),
                selectInput("clean_table_select", "Select Table:",
                  choices = c("documents", "stations", "station_reports", 
                             "women_admission", "troops", "hospital_operations")
                ),
                actionButton("find_duplicates", "Find Duplicates", class = "btn-warning"),
                br(), br(),
                DT::dataTableOutput("duplicates_table")
              ),
              
              tabPanel("Data Validation",
                br(),
                selectInput("validate_table_select", "Select Table:",
                  choices = c("documents", "stations", "station_reports", 
                             "women_admission", "troops", "hospital_operations")
                ),
                actionButton("validate_data", "Validate Data", class = "btn-info"),
                br(), br(),
                verbatimTextOutput("validation_results")
              ),
              
              tabPanel("Filter & Search",
                br(),
                selectInput("filter_table_select", "Select Table:",
                  choices = c("documents", "stations", "station_reports", 
                             "women_admission", "troops", "hospital_operations")
                ),
                uiOutput("filter_controls"),
                br(),
                DT::dataTableOutput("filtered_table")
              )
            )
          )
        )
      ),
      
      # Hospital Notes Tab
      tabItem(tabName = "hospital_notes",
        fluidRow(
          box(
            title = "Hospital Notes (Cleaned)", status = "primary", solidHeader = TRUE,
            width = 12,
            fluidRow(
              column(3,
                uiOutput("hn_station_select")
              ),
              column(3,
                uiOutput("hn_year_range")
              ),
              column(3,
                selectInput("hn_country", "Country:", choices = c("All"), selected = "All")
              ),
              column(3,
                textInput("hn_search", "Search Notes:", placeholder = "Find text in notes/remarks")
              )
            ),
            br(),
            fluidRow(
              column(12,
                DT::dataTableOutput("hospital_notes_table")
              )
            ),
            br(),
            fluidRow(
              column(6, downloadButton("download_hospital_notes", "Download CSV", class = "btn-success")),
              column(6, actionButton("hn_save_to_db", "Save Cleaned to Database", class = "btn-primary"))
            ),
            br(),
            verbatimTextOutput("hn_save_status")
          )
        )
      ),

      # Export Tab
      tabItem(tabName = "export",
        fluidRow(
          box(
            title = "Data Export", status = "success", solidHeader = TRUE,
            width = 12,
            fluidRow(
              column(12,
                selectInput("export_table", "Select Table to Export:",
                  choices = c("documents", "stations", "station_reports", 
                             "women_admission", "troops", "hospital_operations")
                ),
                selectInput("export_format", "Export Format:",
                  choices = c("CSV", "Excel", "JSON")
                ),
                actionButton("export_data", "Export Data", class = "btn-success")
              )
            ),
            br(),
            verbatimTextOutput("export_status")
          )
        )
      )
    )
  )
)

# Server
server <- function(input, output, session) {
  message('SHINY_SESSION_START token=', session$token, ' pid=', Sys.getpid())
  session$onSessionEnded(function() {
    message('SHINY_SESSION_END token=', session$token)
  })
  
  # Database connection: open a single connection at session start and reuse it
  con_obj <- connect_to_db()
  conn <- reactive({
    con_obj
  })
  
  # Load railway shapefiles (MOVED INSIDE SERVER FUNCTION)
  railway_lines <- tryCatch({
    message("Loading railway_lines.shp...")
    lines <- st_read("data_raw/railway_lines.shp", quiet = TRUE)
    message(sprintf("SUCCESS: railway_lines loaded with %d features", nrow(lines)))
    lines
  }, error = function(e) {
    message("ERROR loading railway lines shapefile: ", e$message)
    NULL
  })
  
  railway_stations <- tryCatch({
    message("Loading railway_stations_extended.shp...")
    stations <- st_read("data_raw/railway_stations_extended.shp", quiet = TRUE)
    message(sprintf("SUCCESS: railway_stations loaded with %d features", nrow(stations)))
    stations
  }, error = function(e) {
    message("ERROR loading railway stations shapefile: ", e$message)
    NULL
  })

  # Enrich railway stations with attributes from nearest railway line
  if (!is.null(railway_lines) && !is.null(railway_stations)) {
    try({
      message("Enriching railway stations with nearest line attributes...")
      rl <- st_transform(railway_lines, 4326)
      rs <- st_transform(railway_stations, 4326)
      idx <- sf::st_nearest_feature(rs, rl)
      rs$nearest_section <- rl$Section[idx]
      rs$nearest_railway <- rl$Railway[idx]
      rs$nearest_year <- rl$Year[idx]
      railway_stations <- rs
      message("Railway stations enriched successfully")
    }, silent = TRUE)
  }

  # Load override CSV if present
  override_path <- "data_raw/railway_lines_override.csv"
  if (file.exists(override_path)) {
    try({
      message("Loading railway lines override from ", override_path)
      ov <- utils::read.csv(override_path, stringsAsFactors = FALSE)
      new_lines <- list()
      if (nrow(ov) > 0 && "station_seq" %in% names(ov)) {
        for (i in seq_len(nrow(ov))) {
          row <- ov[i, , drop = FALSE]
          stations <- strsplit(as.character(row$station_seq), ",")[[1]]
          stations <- trimws(stations)
          coords <- lapply(stations, function(s) {
            m <- which(tolower(railway_stations$orig_name) == tolower(s) | tolower(railway_stations$modern_nam) == tolower(s))
            if (length(m) == 0) return(NULL)
            c(railway_stations$lon[m[1]], railway_stations$lat[m[1]])
          })
          coords <- Filter(Negate(is.null), coords)
          if (length(coords) >= 2) {
            mat <- do.call(rbind, coords)
            ls <- sf::st_linestring(mat)
            sfc <- sf::st_sfc(ls, crs = 4326)
            sfobj <- sf::st_sf(data.frame(Section = row$Section, Railway = row$Railway, Year = row$Year, stringsAsFactors = FALSE), geometry = sfc)
            new_lines[[length(new_lines) + 1]] <- sfobj
          }
        }
      } else if (nrow(ov) > 0 && all(c("station","seq","Section","Railway") %in% names(ov))) {
        grp_keys <- unique(paste(ov$Section, ov$Railway, ov$Year, sep = "__"))
        for (g in grp_keys) {
          parts <- strsplit(g, "__", fixed = TRUE)[[1]]
          sec <- parts[1]; rail <- parts[2]; yr <- parts[3]
          sub <- ov[ov$Section == sec & ov$Railway == rail & as.character(ov$Year) == as.character(yr), ]
          sub <- sub[order(as.numeric(sub$seq)), ]
          stations <- trimws(as.character(sub$station))
          coords <- lapply(stations, function(s) {
            m <- which(tolower(railway_stations$orig_name) == tolower(s) | tolower(railway_stations$modern_nam) == tolower(s))
            if (length(m) == 0) return(NULL)
            c(railway_stations$lon[m[1]], railway_stations$lat[m[1]])
          })
          coords <- Filter(Negate(is.null), coords)
          if (length(coords) >= 2) {
            mat <- do.call(rbind, coords)
            ls <- sf::st_linestring(mat)
            sfc <- sf::st_sfc(ls, crs = 4326)
            sfobj <- sf::st_sf(data.frame(Section = sec, Railway = rail, Year = yr, stringsAsFactors = FALSE), geometry = sfc)
            new_lines[[length(new_lines) + 1]] <- sfobj
          }
        }
      }

      if (length(new_lines) > 0) {
        new_sf <- do.call(rbind, new_lines)
        if (is.null(railway_lines)) {
          railway_lines <- new_sf
        } else {
          railway_lines <- rbind(railway_lines, new_sf)
        }
        message("Appended ", length(new_lines), " override railway lines from CSV")
      }
    }, silent = TRUE)
  }

  # On app start, set the year slider to 1873 (earliest year with data)
  try({
    updateSliderInput(session, "year_slider", value = 1873)
  }, silent = TRUE)
  
  # ===== INTERACTIVE MAP FUNCTIONALITY =====
  # Reactive data for map - joins stations, women admissions, and acts
  map_data <- reactive({
    # Single year only
    selected_year <- input$year_slider
    message(sprintf("Fetching map data for year: %d", selected_year))
    
    con <- conn()
    if (!DBI::dbIsValid(con)) {
      message("Database connection is not valid")
      return(data.frame())
    }
    
    # Get stations with coordinates
    stations <- tryCatch({
      dbGetQuery(con, "SELECT * FROM stations WHERE latitude IS NOT NULL AND longitude IS NOT NULL")
    }, error = function(e) {
      message("Error querying stations: ", e$message)
      return(data.frame())
    })
    
    message(sprintf("Found %d stations with coordinates", nrow(stations)))
    
    if (nrow(stations) == 0) {
      return(data.frame())
    }
    
    # Get women admission data for selected year only
    women_data <- tryCatch({
      dbGetQuery(con, sprintf("
        SELECT station, 
               avg_registered as total_registered, 
               women_added as total_added,
               women_removed as total_removed
        FROM women_admission 
        WHERE year = %d", selected_year))
    }, error = function(e) {
      message("Error querying women_admission: ", e$message)
      return(data.frame())
    })
    
    message(sprintf("Found %d stations with women data for year %d", nrow(women_data), selected_year))
    
    # Get hospital operations data for acts for selected year
    # Group by station to handle multiple acts per station-year
    hospital_data <- tryCatch({
      dbGetQuery(con, sprintf("
        SELECT station, 
               GROUP_CONCAT(act, '; ') as act,
               COUNT(DISTINCT act) as n_acts
        FROM hospital_operations
        WHERE year = %d AND act IS NOT NULL AND act != ''
        GROUP BY station", selected_year))
    }, error = function(e) {
      message("Error querying hospital_operations: ", e$message)
      return(data.frame())
    })
    
    message(sprintf("Found %d stations with hospital operations for year %d", nrow(hospital_data), selected_year))
    
    # Join data (now one-to-one joins, no duplicates)
    map_df <- stations %>%
      dplyr::left_join(women_data, by = c("name" = "station")) %>%
      dplyr::left_join(hospital_data, by = c("name" = "station")) %>%
      dplyr::mutate(
        total_registered = round(ifelse(is.na(total_registered), 0, total_registered), 0),
        total_added = round(ifelse(is.na(total_added), 0, total_added), 0),
        total_removed = round(ifelse(is.na(total_removed), 0, total_removed), 0),
        # Flag stations with no data
        has_data = total_added > 0 | total_registered > 0 | total_removed > 0,
  # Smaller radius for hospital circles (reduced visibility)
  # Use total_registered (total women) for circle size instead of total_added
  radius = ifelse(has_data, pmax(3, sqrt(pmax(0, total_registered)) * 2), 3),
        # For display: extract primary (first) act for color coding
        primary_act = ifelse(is.na(act), NA, sub(";.*", "", act)),
        # Flag for multiple acts
        multiple_acts = !is.na(n_acts) & n_acts > 1
      )
    
    # No act filters applied here — show all stations and display acts in popups.
    
    message(sprintf("Returning %d stations for map display", nrow(map_df)))
    map_df
  })
  
  # Helper: draw railway overlays (lines + stations) for a given year
    draw_rail_overlays <- function(selected_year) {
      # defensive
      if (is.null(selected_year)) return(invisible(NULL))
      if (is.null(railway_lines) && is.null(railway_stations)) return(invisible(NULL))

      message(sprintf("draw_rail_overlays() called for year: %s", as.character(selected_year)))
      
      # Debug: check railway_lines state
      if (is.null(railway_lines)) {
        message("railway_lines is NULL - no lines to draw")
        railways_filtered <- NULL
      } else {
        message(sprintf("railway_lines has %d rows", nrow(railway_lines)))
        # prepare filtered lines
        rail_year <- suppressWarnings(as.numeric(as.character(railway_lines$Year)))
        message(sprintf("rail_year values: %s", paste(head(rail_year, 10), collapse=", ")))
        railways_filtered <- tryCatch({
          filtered <- railway_lines[ ( !is.na(rail_year) & rail_year <= selected_year ) | is.na(rail_year), ]
          message(sprintf("After filtering by year <= %s: %d rows", selected_year, nrow(filtered)))
          filtered
        }, error = function(e) {
          message(sprintf("Error filtering railway_lines: %s", e$message))
          railway_lines
        })
      }

      # prepare filtered stations based on nearest_year (if available)
      railway_stations_filtered <- railway_stations
      if (!is.null(railway_stations) && nrow(railway_stations) > 0) {
        ny <- tryCatch({ suppressWarnings(as.numeric(as.character(railway_stations$nearest_year))) }, error = function(e) rep(NA, nrow(railway_stations)))
        railway_stations_filtered <- tryCatch({
          railway_stations[ ( !is.na(ny) & ny <= selected_year ) | is.na(ny), ]
        }, error = function(e) railway_stations)
      }

      proxy <- leafletProxy("map")
      proxy %>% clearGroup("railways") %>% clearGroup("railway_stations")

      if (!is.null(railways_filtered) && nrow(railways_filtered) > 0) {
        message(sprintf("Drawing railway lines - filtered rows: %d", nrow(railways_filtered)))
        
        # Draw lines manually using lng/lat pairs from sf geometry
        for (i in seq_len(nrow(railways_filtered))) {
          tryCatch({
            line_coords <- st_coordinates(railways_filtered[i, ])
            if (nrow(line_coords) >= 2) {
              proxy <- proxy %>% addPolylines(
                lng = line_coords[, "X"],
                lat = line_coords[, "Y"],
                color = "#d62728",
                weight = 3,
                opacity = 0.8,
                group = "railways",
                popup = paste0(
                  "<b>Railway Section</b><br>",
                  "Section: ", railways_filtered$Section[i], "<br>",
                  "Line: ", railways_filtered$Railway[i], "<br>",
                  "Year Opened: ", railways_filtered$Year[i]
                ),
                label = paste0(railways_filtered$Section[i], " - ", railways_filtered$Railway[i])
              )
            }
          }, error = function(e) {
            message(sprintf("Error drawing line %d: %s", i, e$message))
          })
        }
        message(sprintf("Successfully processed %d railway lines", nrow(railways_filtered)))
      }

      if (!is.null(railway_stations_filtered) && nrow(railway_stations_filtered) > 0) {
        message(sprintf("railway_stations_filtered rows: %d", nrow(railway_stations_filtered)))
        proxy %>% addCircleMarkers(
          data = railway_stations_filtered,
          radius = 4,
          color = "#f39c12",
          fillColor = "#f1c40f",
          fillOpacity = 0.8,
          weight = 1.5,
          group = "railway_stations",
          popup = ~paste0(
            "<b>Railway Station</b><br>",
            "Historic: ", orig_name, "<br>",
            "Modern: ", modern_nam,
            if (!is.null(nearest_section)) paste0("<br><b>Section:</b> ", nearest_section) else "",
            if (!is.null(nearest_railway)) paste0("<br><b>Line:</b> ", nearest_railway) else "",
            if (!is.null(nearest_year)) paste0("<br><b>Year Opened:</b> ", nearest_year) else ""
          ),
          label = ~orig_name
        )
      }
      invisible(NULL)
    }
  
  # Load British India boundary (modern India, Pakistan, Bangladesh, Myanmar borders as proxy)
  india_boundary <- tryCatch({
    # Get country boundaries for the Indian subcontinent
    india <- ne_countries(scale = "medium", country = c("India", "Pakistan", "Bangladesh", "Myanmar"), returnclass = "sf")
    # Ensure CRS is EPSG:4326 (WGS84)
    st_transform(india, crs = 4326)
  }, error = function(e) {
    message("Could not load boundary data: ", e$message)
    NULL
  })
  
  # Initialize the base map
  output$map <- renderLeaflet({
    message("Initializing base map")
    map <- leaflet() %>%
      addProviderTiles(providers$CartoDB.Positron) %>%
      setView(lng = 78.9629, lat = 20.5937, zoom = 5)
    
    # Add British India boundary if available
    if (!is.null(india_boundary)) {
      map <- map %>%
        addPolygons(
          data = india_boundary,
          fillColor = "transparent",
          fillOpacity = 0,
          color = "#8B4513",  # Saddle brown
          weight = 2,
          opacity = 0.6,
          dashArray = "5, 5",  # Dashed line
          group = "boundary",
          popup = ~name
        )
    }

    # Add initial hospital markers so the map shows data on first render
    # Use map_data() reactive to get the current station-year rows
    try({
      init_data <- map_data()
      if (is.data.frame(init_data) && nrow(init_data) > 0) {
        init_data <- init_data %>%
          dplyr::mutate(
            marker_color = dplyr::case_when(
              !has_data ~ "#ecf0f1",
              is.na(primary_act) ~ "#2c3e50",
              grepl("1864", primary_act, ignore.case = TRUE) ~ "#e74c3c",
              grepl("1868", primary_act, ignore.case = TRUE) ~ "#3498db",
              grepl("1880", primary_act, ignore.case = TRUE) ~ "#9b59b6",
              grepl("1889", primary_act, ignore.case = TRUE) ~ "#f39c12",
              grepl("voluntary", primary_act, ignore.case = TRUE) ~ "#27ae60",
              TRUE ~ "#ecf0f1"
            ),
            marker_opacity = ifelse(has_data, 0.6, 0.4)
          )

        map <- map %>%
          addCircleMarkers(
            data = init_data,
            lng = ~longitude,
            lat = ~latitude,
            radius = ~radius,
            group = "lock_hospitals",
            popup = ~paste0(
              "<b>Lock Hospital: ", name, "</b><br>",
              "Region: ", region, "<br>",
              "Year: ", input$year_slider, "<br>",
              ifelse(has_data,
                paste0("<b>Women Added: ", total_added, "</b><br>", "Total Registered: ", total_registered, "<br>", "Removed: ", total_removed, "<br>"),
                "<i style='color:#7f8c8d;'>No admission data for this year</i><br>"
              ),
              ifelse(is.na(act), "Act: None", act)
            ),
            label = ~name,
            fillColor = ~marker_color,
            fillOpacity = ~marker_opacity,
            color = "#2c3e50",
            weight = 1,
            stroke = TRUE
          )
      }
    }, silent = TRUE)
    
    map
  })

    # Ensure initial markers are added after the UI has flushed to the client. Using
    # session$onFlushed guarantees the leaflet map exists on the client before we
    # attempt to proxy-add markers. Run once only.
    session$onFlushed(function() {
      try({
        init_data <- map_data()
        if (is.data.frame(init_data) && nrow(init_data) > 0) {
          init_data <- init_data %>%
            dplyr::mutate(
              marker_color = dplyr::case_when(
                !has_data ~ "#ecf0f1",
                is.na(primary_act) ~ "#2c3e50",
                grepl("1864", primary_act, ignore.case = TRUE) ~ "#e74c3c",
                grepl("1868", primary_act, ignore.case = TRUE) ~ "#3498db",
                grepl("1880", primary_act, ignore.case = TRUE) ~ "#9b59b6",
                grepl("1889", primary_act, ignore.case = TRUE) ~ "#f39c12",
                grepl("voluntary", primary_act, ignore.case = TRUE) ~ "#27ae60",
                TRUE ~ "#ecf0f1"
              ),
              marker_opacity = ifelse(has_data, 0.6, 0.4)
            )

          leafletProxy("map") %>%
            clearGroup("lock_hospitals") %>%
            addCircleMarkers(
              data = init_data,
              lng = ~longitude,
              lat = ~latitude,
              radius = ~radius,
              group = "lock_hospitals",
              popup = ~paste0(
                "<b>Lock Hospital: ", name, "</b><br>",
                "Region: ", region, "<br>",
                "Year: ", input$year_slider, "<br>",
                ifelse(has_data,
                  paste0("<b>Women Added: ", total_added, "</b><br>", "Total Registered: ", total_registered, "<br>", "Removed: ", total_removed, "<br>"),
                  "<i style='color:#7f8c8d;'>No admission data for this year</i><br>"
                ),
                ifelse(is.na(act), "Act: None", act)
              ),
              label = ~name,
              fillColor = ~marker_color,
              fillOpacity = ~marker_opacity,
              color = "#2c3e50",
              weight = 1,
              stroke = TRUE
            )
        }
      }, silent = TRUE)
    }, once = TRUE)
  
  # Update railway overlays when checkbox changes or year changes
  observeEvent(list(input$show_railways, input$year_slider), {
    # Use observeEvent so we trigger when show_railways or year_slider change
    req(input$year_slider)
    
    show_rail <- isTRUE(input$show_railways)
    message(sprintf("Railway overlay observer triggered: show_railways=%s year=%s", 
                    as.character(show_rail), as.character(input$year_slider)))
    
    if (show_rail && !is.null(railway_lines) && !is.null(railway_stations)) {
      # Delegate drawing to centralized helper (handles filtering by year and clearing groups)
      message("Attempting to draw railway overlays...")
      tryCatch({
        draw_rail_overlays(input$year_slider)
        message("Railway overlays drawn successfully")
      }, error = function(e) {
        message(sprintf("ERROR drawing railway overlays: %s", e$message))
      })
    } else {
      message("Clearing railway layers from map")
      leafletProxy("map") %>%
        clearGroup("railways") %>%
        clearGroup("railway_stations")
    }
  }, ignoreNULL = FALSE, ignoreInit = FALSE)
  
  # Update map markers when data or filters change
  observe({
    req(input$year_slider)
    
    # Always show hospital markers (no toggle)
    
    data <- map_data()
    
    if (nrow(data) == 0) {
      message("No map data to display")
      leafletProxy("map") %>%
        clearGroup("lock_hospitals")
      return()
    }
    
    message(sprintf("Updating map with %d hospital markers", nrow(data)))
    
    # Assign colors based on act type and data availability
    # NOTE: act text in the DB can use multiple naming conventions (e.g. "Act XXII of 1864", "Cantonment Act 1864",
    # "Act XIV of 1868", "Contagious Diseases Act 1868"). Match by year/keyword substrings rather than exact equality
    data <- data %>%
      dplyr::mutate(
        # primary_act may contain different phrasings; test for year tokens or keywords to decide color
        marker_color = dplyr::case_when(
          !has_data ~ "#ecf0f1",                                           # Very light grey for no women data
          is.na(primary_act) ~ "#2c3e50",                                    # Dark charcoal for data but no act
          grepl("1864", primary_act, ignore.case = TRUE) ~ "#e74c3c",       # Red for 1864-era acts
          grepl("1868", primary_act, ignore.case = TRUE) ~ "#3498db",       # Blue for 1868 acts
          grepl("1880", primary_act, ignore.case = TRUE) ~ "#9b59b6",       # Purple for 1880 acts
          grepl("1889", primary_act, ignore.case = TRUE) ~ "#f39c12",       # Orange for 1889/late acts
          grepl("voluntary", primary_act, ignore.case = TRUE) ~ "#27ae60",  # Green for Voluntary System
          TRUE ~ "#ecf0f1"                                                   # Default very light grey
        ),
        # Reduced opacity for all hospital markers (semi-transparent)
        marker_opacity = ifelse(has_data, 0.6, 0.4)
      )
    
    leafletProxy("map", data = data) %>%
      clearGroup("lock_hospitals") %>%
      addCircleMarkers(
        lng = ~longitude,
        lat = ~latitude,
        radius = ~radius,
        group = "lock_hospitals",
        popup = ~paste0(
          "<b>Lock Hospital: ", name, "</b><br>",
          "Region: ", region, "<br>",
          "Year: ", input$year_slider, "<br>",
          ifelse(has_data, 
            paste0(
              "<b>Women Added: ", total_added, "</b><br>",
              "Total Registered: ", total_registered, "<br>",
              "Removed: ", total_removed, "<br>"
            ),
            "<i style='color:#7f8c8d;'>No admission data for this year</i><br>"
          ),
          ifelse(is.na(act), 
            "Act: None", 
            ifelse(multiple_acts,
              paste0("<b>Acts: ", act, "</b> (multiple acts)"),
              paste0("Act: ", act)
            )
          )
        ),
        label = ~name,
        fillColor = ~marker_color,
        fillOpacity = ~marker_opacity,
        color = "#2c3e50",
        weight = 1,
        stroke = TRUE
      )
  })
  
  # Map legend
  output$map_legend <- renderUI({
    railway_legend <- if (!is.null(input$show_railways) && input$show_railways) {
      '<div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #ddd;">
        <strong style="font-size: 11px;">Railway Infrastructure</strong>
        <div style="margin-top: 5px; font-size: 11px; line-height: 1.8;">
          <i class="fa fa-circle" style="color: #f1c40f; font-size: 10px;"></i> Railway Stations
        </div>
      </div>'
    } else {
      ""
    }
    
    hospital_legend <- '<div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #ddd;">
        <strong style="font-size: 11px;">Lock Hospitals</strong>
  <div style="font-size: 10px; color: #7f8c8d; margin-top: 3px; margin-bottom: 5px;">Circle size = avg. registered women</div>
      </div>'
    
    HTML(paste0('
      <div style="font-size: 11px;">
        ', railway_legend, hospital_legend, '
        <strong style="font-size: 11px;">Contagious Diseases Acts</strong>
        <div style="margin-top: 5px; font-size: 11px; line-height: 1.8;">
          <i class="fa fa-circle" style="color: #e74c3c;"></i> Cantonment Act 1864<br>
          <i class="fa fa-circle" style="color: #3498db;"></i> Contagious Diseases Act 1868<br>
          <i class="fa fa-circle" style="color: #9b59b6;"></i> Cantonment Act 1880<br>
          <i class="fa fa-circle" style="color: #f39c12;"></i> Cantonment Act 1889<br>
          <i class="fa fa-circle" style="color: #27ae60;"></i> Voluntary System<br>
          <i class="fa fa-circle" style="color: #2c3e50;"></i> Data, No Act<br>
          <i class="fa fa-circle" style="color: #ecf0f1; opacity: 0.9;"></i> No Data
        </div>
      </div>
    '))
  })
  
  # Map data table - shows Lock Hospital admission data for selected year
  output$map_data_table <- DT::renderDataTable({
    data <- map_data()
    
    if (nrow(data) == 0) {
      return(DT::datatable(data.frame(Message = "No data available for selected year and filters")))
    }
    
    # Filter to show only stations with women data (non-zero registered or added)
    data_filtered <- data %>%
      dplyr::filter(total_registered > 0 | total_added > 0)
    
    # If no stations have data for this year, show a message
    if (nrow(data_filtered) == 0) {
      return(DT::datatable(data.frame(Message = paste0("No women admission data available for year ", input$year_slider, ". Try a different year (1873-1889)."))))
    }
    
    # Select and rename columns for display
    display_data <- data_filtered %>%
      dplyr::select(
        Station = name,
        Region = region,
        Country = country,
        `Women Registered` = total_registered,
        `Women Added` = total_added,
        Act = act
      ) %>%
      dplyr::mutate(
        `Women Registered` = round(`Women Registered`, 0),
        `Women Added` = round(`Women Added`, 0)
      ) %>%
      dplyr::arrange(desc(`Women Added`))
    
    DT::datatable(
      display_data,
      options = list(
        pageLength = 10,
        scrollX = FALSE,
        dom = 'ftip',
        initComplete = JS(
          "function(settings, json) {",
          "$(this.api().table().header()).css({'background-color': '#3498db', 'color': '#fff'});",
          "}"
        )
      ),
      rownames = FALSE,
      filter = 'none'
    )
  })
  
  # Railway lines table - shows lines operational in selected year
  output$railway_lines_table <- DT::renderDataTable({
    req(input$year_slider)
    
    if (is.null(railway_lines)) {
      return(DT::datatable(data.frame(Message = "Railway data not available")))
    }
    
    selected_year <- input$year_slider
    railways_filtered <- railway_lines[railway_lines$Year <= selected_year, ]
    
    if (nrow(railways_filtered) == 0) {
      return(DT::datatable(data.frame(Message = paste("No railways operational by", selected_year))))
    }
    
    # Convert to regular dataframe and select columns
    display_data <- as.data.frame(railways_filtered) %>%
      dplyr::select(
        Section = Section,
        Railway = Railway,
        `Year Opened` = Year,
        `Distance (miles)` = Miles,
        From = start_name,
        To = end_name
      ) %>%
      dplyr::arrange(`Year Opened`)
    
    DT::datatable(
      display_data,
      options = list(
        pageLength = 10,
        scrollX = FALSE,
        dom = 'ftip'
      ),
      rownames = FALSE
    )
  })
  
  # Railway stations table
  # ===== END INTERACTIVE MAP FUNCTIONALITY =====
  
  # Image Gallery Navigation
  current_image_index <- reactiveVal(1)
  
  observeEvent(input$next_image, {
    img_dir <- "content/images_safe"
    img_files <- list.files(img_dir, pattern = "\\.(jpg|jpeg|png|gif|webp)$", ignore.case = TRUE)
    current <- current_image_index()
    if (length(img_files) > 0 && current < length(img_files)) {
      current_image_index(current + 1)
    }
  }, ignoreInit = TRUE, priority = 1)
  
  observeEvent(input$prev_image, {
    img_dir <- "content/images_safe"
    img_files <- list.files(img_dir, pattern = "\\.(jpg|jpeg|png|gif|webp)$", ignore.case = TRUE)
    current <- current_image_index()
    if (length(img_files) > 0 && current > 1) {
      current_image_index(current - 1)
    }
  }, ignoreInit = TRUE, priority = 1)
  
  # Close connection when app stops
  onStop(function() {
    try({ DBI::dbDisconnect(con_obj) }, silent = TRUE)
  })
  
  # Overview Tab - Value Boxes
  output$story_total_stats <- renderUI({
    n_docs <- dbGetQuery(conn(), "SELECT COUNT(*) as count FROM documents")$count
    n_stations <- dbGetQuery(conn(), "SELECT COUNT(*) as count FROM stations")$count
    n_women <- dbGetQuery(conn(), "SELECT COUNT(*) as count FROM women_admission")$count
    n_troops <- dbGetQuery(conn(), "SELECT COUNT(*) as count FROM troops")$count

    # Calculate year ranges and missing years for all datasets
    women <- women_df()
    troops <- troops_df()
    ops <- tryCatch(ops_df(), error = function(e) data.frame())

    # Helper: get missing years in contiguous range
    get_missing_years <- function(years) {
      years <- sort(unique(na.omit(years)))
      if (length(years) < 2) return(character(0))
      yr_min <- min(years)
      yr_max <- max(years)
      expected <- seq(yr_min, yr_max)
      missing <- setdiff(expected, years)
      if (length(missing) > 0) return(as.character(missing))
      character(0)
    }

    # Overall combined years across all datasets
    all_years <- c(
      if (nrow(women) > 0 && "year" %in% names(women)) women$year else numeric(0),
      if (nrow(troops) > 0 && "year" %in% names(troops)) troops$year else numeric(0),
      if (nrow(ops) > 0 && "year" %in% names(ops)) ops$year else numeric(0)
    )
    overall_missing <- get_missing_years(all_years)

    # Per-region combined years across datasets
    regions <- sort(unique(na.omit(c(
      if (nrow(women) > 0 && "region" %in% names(women)) women$region else character(0),
      if (nrow(troops) > 0 && "region" %in% names(troops)) troops$region else character(0),
      if (nrow(ops) > 0 && "region" %in% names(ops)) ops$region else character(0)
    ))))

    region_missing_parts <- c()
    if (length(regions) > 0) {
      for (r in regions) {
        years_r <- c(
          if (nrow(women) > 0 && all(c("region","year") %in% names(women))) women$year[women$region == r] else numeric(0),
          if (nrow(troops) > 0 && all(c("region","year") %in% names(troops))) troops$year[troops$region == r] else numeric(0),
          if (nrow(ops) > 0 && all(c("region","year") %in% names(ops))) ops$year[ops$region == r] else numeric(0)
        )
        miss_r <- get_missing_years(years_r)
        if (length(miss_r) > 0) {
          region_missing_parts <- c(region_missing_parts, paste0(r, ": ", paste(miss_r, collapse = ", ")))
        }
      }
    }

    # Build concise missing years line(s)
    missing_line <- ""
    if (length(overall_missing) > 0 || length(region_missing_parts) > 0) {
      overall_text <- if (length(overall_missing) > 0) paste0("We were not able to gather info for these years (overall): ", paste(overall_missing, collapse = ", ")) else NULL
      region_text <- if (length(region_missing_parts) > 0) paste0("By region: ", paste(region_missing_parts, collapse = " | ")) else NULL
      line_text <- paste(na.omit(c(overall_text, region_text)), collapse = ". ")
      missing_line <- paste0("<div style='margin-top:10px; color:#7f8c8d; font-size:0.95em;'>", line_text, ".</div>")
    }

    HTML(paste0(
      "<div>",
      "<!-- Flexbox container for horizontal KPI boxes -->",
      "<div style='display: flex; justify-content: space-between; align-items: center; gap: 20px; flex-wrap: wrap; margin-bottom: 20px;'>",
      "  <div style='flex: 1; min-width: 200px; text-align: center; padding: 20px; background: rgba(52, 152, 219, 0.05); border-radius: 8px; border-top: 3px solid #3498db;'>",
      "    <div style='font-size: 3em; font-weight: bold; color: #3498db;'>", n_stations, "</div>",
      "    <div style='font-size: 1.1em; color: #7f8c8d; margin-top: 10px;'>Stations</div>",
      "  </div>",
      "  <div style='flex: 1; min-width: 200px; text-align: center; padding: 20px; background: rgba(231, 76, 60, 0.05); border-radius: 8px; border-top: 3px solid #e74c3c;'>",
      "    <div style='font-size: 3em; font-weight: bold; color: #e74c3c;'>", n_women, "</div>",
      "    <div style='font-size: 1.1em; color: #7f8c8d; margin-top: 10px;'>Women Records</div>",
      "  </div>",
      "  <div style='flex: 1; min-width: 200px; text-align: center; padding: 20px; background: rgba(243, 156, 18, 0.05); border-radius: 8px; border-top: 3px solid #f39c12;'>",
      "    <div style='font-size: 3em; font-weight: bold; color: #f39c12;'>", n_troops, "</div>",
      "    <div style='font-size: 1.1em; color: #7f8c8d; margin-top: 10px;'>Troop Records</div>",
      "  </div>",
      "  <div style='flex: 1; min-width: 200px; text-align: center; padding: 20px; background: rgba(155, 89, 182, 0.05); border-radius: 8px; border-top: 3px solid #9b59b6;'>",
      "    <div style='font-size: 3em; font-weight: bold; color: #9b59b6;'>", n_docs, "</div>",
      "    <div style='font-size: 1.1em; color: #7f8c8d; margin-top: 10px;'>Source Documents</div>",
      "  </div>",
      "</div>",
      missing_line,
      "</div>"
    ))
  })
  
  # Quality Summary Table
  output$quality_summary <- DT::renderDataTable({
    tables <- c("women_admission", "troops", "hospital_operations", "stations")
    total_records <- sapply(tables, function(t) {
      dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t))$count
    })
    complete_records <- sapply(tables, function(t) {
      # Check what columns exist in the table first
      cols <- dbGetQuery(conn(), paste0("PRAGMA table_info(", t, ")"))$name
      
      if (t %in% c("women_admission", "troops")) {
        if ("doc_id" %in% cols && "source_name" %in% cols) {
          dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t, "WHERE doc_id IS NOT NULL AND source_name IS NOT NULL"))$count
        } else {
          dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t))$count
        }
      } else if (t == "hospital_operations") {
        # hospital_operations now only has station, year, act
        # Consider complete if station and year are not null
        if ("station" %in% cols && "year" %in% cols) {
          dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t, "WHERE station IS NOT NULL AND year IS NOT NULL"))$count
        } else {
          dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t))$count
        }
      } else if (t == "stations") {
        dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t, "WHERE name IS NOT NULL"))$count
      } else {
        if ("unique_id" %in% cols) {
          dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t, "WHERE unique_id IS NOT NULL"))$count
        } else if ("hid" %in% cols) {
          dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t, "WHERE hid IS NOT NULL"))$count
        } else {
          # Fallback: consider all records complete
          dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", t))$count
        }
      }
    })
    quality_data <- data.frame(Table = tables, Total_Records = total_records, Complete_Records = complete_records)
    quality_data$Completeness <- round(quality_data$Complete_Records / quality_data$Total_Records * 100, 1)
    quality_data
  }, options = list(pageLength = 6, dom = 't'))
  
  # (Removed) Missing Data Plot - intentionally removed as per request
  
  # Data Tables Tab - reactive trigger for refreshing table
  table_refresh <- reactiveVal(0)
  
  output$data_table <- DT::renderDataTable({
    # Add dependency on refresh trigger
    table_refresh()
    # Try to fetch rowid; some tables or views may not expose rowid, so fallback
    query_rowid <- paste("SELECT rowid, * FROM", input$table_select)
    data <- tryCatch({
      d <- dbGetQuery(conn(), query_rowid)
      # Mark that rowid was available
      attr(d, 'rowid_available') <- TRUE
      d
    }, error = function(e) {
      # Fallback: select all columns, create a synthetic rownum and mark table non-editable
      dat <- tryCatch(dbGetQuery(conn(), paste("SELECT * FROM", input$table_select)), error = function(e2) {
        # If even this fails, return empty data.frame
        return(data.frame())
      })
      if (nrow(dat) > 0) dat$.__rownum__ <- seq_len(nrow(dat))
      attr(dat, 'rowid_available') <- FALSE
      dat
    })
    rowid_available <- isTRUE(attr(data, 'rowid_available'))

    # Log debug info for table rendering
    try({
      message(sprintf('data_table render: table=%s rows=%d rowid_available=%s', input$table_select, nrow(data), as.character(rowid_available)))
    }, silent = TRUE)

    if (!rowid_available) {
      # Non-editable fallback table
      DT::datatable(data, 
        editable = FALSE,
        selection = 'single',
        options = list(pageLength = 25, scrollX = TRUE, dom = 'Bfrtip', buttons = c('copy','csv','excel','print')), 
        extensions = 'Buttons',
        rownames = FALSE
      )
    } else {
      DT::datatable(data, 
        editable = list(target = 'cell', disable = list(columns = 0)),  # Make cells editable except rowid
        selection = 'single',  # Enable row selection for delete
        options = list(
          pageLength = 25,
          scrollX = TRUE,
          dom = 'Bfrtip',
          buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
        ), 
        extensions = 'Buttons',
        rownames = FALSE
      )
    }
  })
  
  # Handle cell edits in data_table
  observeEvent(input$data_table_cell_edit, {
    info <- input$data_table_cell_edit
    req(info, input$table_select)
    
    # Get current data (try rowid, otherwise abort with notification)
    data <- tryCatch(dbGetQuery(conn(), paste("SELECT rowid, * FROM", input$table_select)), error = function(e) {
      showNotification("This table is not editable (rowid not available).", type = 'warning', duration = 5)
      return(NULL)
    })
    req(is.data.frame(data))
    
    # Extract edit info
    row_num <- info$row
    col_num <- info$col + 1  # R is 1-indexed, JS is 0-indexed
    new_value <- info$value
    
    # Get rowid and column name
    rowid <- data[row_num, "rowid"]
    col_name <- names(data)[col_num]
    
    # Skip if trying to edit rowid
    if (col_name == "rowid") return()
    
    # Build UPDATE query
    update_query <- sprintf(
      "UPDATE %s SET %s = ? WHERE rowid = ?",
      input$table_select,
      col_name
    )
    
    # Execute update
    tryCatch({
      dbExecute(conn(), update_query, params = list(new_value, rowid))
      showNotification(
        paste("Updated", col_name, "in row", row_num),
        type = "message",
        duration = 3
      )
    }, error = function(e) {
      showNotification(
        paste("Error updating:", e$message),
        type = "error",
        duration = 5
      )
    })
  })
  
  # Delete selected row
  observeEvent(input$delete_row_btn, {
    # Only respond to a real user click (actionButton increments from 0)
    req(isTRUE(!is.null(input$delete_row_btn)) && input$delete_row_btn > 0)
    req(input$data_table_rows_selected, input$table_select)
    
    # Get current data
    query <- paste("SELECT rowid, * FROM", input$table_select)
    data <- dbGetQuery(conn(), query)
    
    # Get selected row
    row_num <- input$data_table_rows_selected
    rowid <- data[row_num, "rowid"]
    
    # Confirm and delete
    showModal(modalDialog(
      title = "Confirm Deletion",
      paste("Are you sure you want to delete row", row_num, "from", input$table_select, "?"),
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_delete", "Delete", class = "btn-danger")
      )
    ))
  })
  
  observeEvent(input$confirm_delete, {
    # guard to ensure this was triggered by a user
    req(isTRUE(!is.null(input$confirm_delete)) && input$confirm_delete > 0)
    req(input$data_table_rows_selected, input$table_select)
    
    # Get current data
    query <- paste("SELECT rowid, * FROM", input$table_select)
    data <- dbGetQuery(conn(), query)
    
    # Get selected row
    row_num <- input$data_table_rows_selected
    rowid <- data[row_num, "rowid"]
    
    # Delete
    tryCatch({
      dbExecute(conn(), paste("DELETE FROM", input$table_select, "WHERE rowid = ?"), params = list(rowid))
      showNotification(
        paste("Deleted row", row_num, "from", input$table_select),
        type = "warning",
        duration = 3
      )
      removeModal()
      # Trigger table refresh
      table_refresh(table_refresh() + 1)
    }, error = function(e) {
      showNotification(
        paste("Error deleting:", e$message),
        type = "error",
        duration = 5
      )
      removeModal()
    })
  })
  
  # Add new row
  observeEvent(input$add_row_btn, {
    # Only respond to user click
    req(isTRUE(!is.null(input$add_row_btn)) && input$add_row_btn > 0)
    req(input$table_select)
    
    # Get table structure
    cols_query <- paste0("PRAGMA table_info(", input$table_select, ")")
    cols_info <- dbGetQuery(conn(), cols_query)
    
    # Create input fields for each column (except rowid and auto-increment primary keys)
    input_fields <- lapply(seq_len(nrow(cols_info)), function(i) {
      col <- cols_info[i, ]
      if (col$name == "rowid" || (col$pk == 1 && grepl("INTEGER", col$type, ignore.case = TRUE))) {
        return(NULL)  # Skip auto-increment primary keys
      }
      textInput(paste0("new_", col$name), label = paste(col$name, ":"), value = "")
    })
    input_fields <- Filter(Negate(is.null), input_fields)
    
    showModal(modalDialog(
      title = paste("Add New Row to", input$table_select),
      do.call(tagList, input_fields),
      footer = tagList(
        modalButton("Cancel"),
        actionButton("confirm_add", "Add Row", class = "btn-success")
      ),
      size = "l"
    ))
  })
  
  observeEvent(input$confirm_add, {
    # Ensure this was triggered by user confirm button
    req(isTRUE(!is.null(input$confirm_add)) && input$confirm_add > 0)
    req(input$table_select)
    
    # Get table structure
    cols_query <- paste0("PRAGMA table_info(", input$table_select, ")")
    cols_info <- dbGetQuery(conn(), cols_query)
    
    # Collect values from inputs
    cols_to_insert <- cols_info %>%
      filter(name != "rowid", !(pk == 1 & grepl("INTEGER", type, ignore.case = TRUE)))
    
    col_names <- cols_to_insert$name
    values <- sapply(col_names, function(nm) {
      val <- input[[paste0("new_", nm)]]
      if (is.null(val) || val == "") NA else val
    })
    
    # Build INSERT query
    placeholders <- paste(rep("?", length(col_names)), collapse = ", ")
    insert_query <- sprintf(
      "INSERT INTO %s (%s) VALUES (%s)",
      input$table_select,
      paste(col_names, collapse = ", "),
      placeholders
    )
    
    # Execute insert
    tryCatch({
      dbExecute(conn(), insert_query, params = as.list(values))
      showNotification(
        paste("Added new row to", input$table_select),
        type = "message",
        duration = 3
      )
      removeModal()
      # Trigger table refresh
      table_refresh(table_refresh() + 1)
    }, error = function(e) {
      showNotification(
        paste("Error adding row:", e$message),
        type = "error",
        duration = 5
      )
    })
  })
  
  # Data Cleaning - Duplicate Detection
  observeEvent(input$find_duplicates, {
    table_name <- input$clean_table_select
    
    if (table_name == "documents") {
      query <- paste("SELECT doc_id, source_name, type, COUNT(*) as count FROM", table_name, 
                     "GROUP BY doc_id, source_name, type HAVING COUNT(*) > 1")
    } else if (table_name == "stations") {
      query <- paste("SELECT name, region, country, COUNT(*) as count FROM", table_name, 
                     "GROUP BY name, region, country HAVING COUNT(*) > 1")
    } else {
      query <- paste("SELECT * FROM", table_name, "WHERE rowid NOT IN (SELECT MIN(rowid) FROM", table_name, "GROUP BY", 
                     ifelse(table_name %in% c("women_admission", "troops"), "unique_id", "hid"), ")")
    }
    
    duplicates <- dbGetQuery(conn(), query)
    output$duplicates_table <- DT::renderDataTable({
      DT::datatable(duplicates, options = list(pageLength = 10))
    })
  })
  
  # Data Cleaning - Validation
  observeEvent(input$validate_data, {
    table_name <- input$validate_table_select
    
    validation_results <- paste("Validation Results for", table_name, ":\n\n")
    
    # Check for NULL values in key columns
    if (table_name == "documents") {
      null_check <- dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", table_name, "WHERE doc_id IS NULL OR source_name IS NULL"))
      validation_results <- paste(validation_results, "Records with NULL doc_id or source_name:", null_check$count, "\n")
    } else if (table_name == "stations") {
      null_check <- dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", table_name, "WHERE name IS NULL"))
      validation_results <- paste(validation_results, "Records with NULL name:", null_check$count, "\n")
    } else if (table_name %in% c("women_admission", "troops")) {
      null_check <- dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", table_name, "WHERE doc_id IS NULL OR source_name IS NULL"))
      validation_results <- paste(validation_results, "Records with NULL doc_id or source_name:", null_check$count, "\n")
    } else if (table_name == "hospital_operations") {
      # hospital_operations only has station, year, act - check for those instead
      null_check <- dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", table_name, "WHERE station IS NULL OR year IS NULL"))
      validation_results <- paste(validation_results, "Records with NULL station or year:", null_check$count, "\n")
    }
    
    # Check for empty strings
    if (table_name %in% c("documents", "women_admission", "troops")) {
      empty_check <- dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", table_name, "WHERE doc_id = '' OR source_name = ''"))
      validation_results <- paste(validation_results, "Records with empty strings:", empty_check$count, "\n")
    } else if (table_name == "hospital_operations") {
      # Check for empty station values instead
      empty_check <- dbGetQuery(conn(), paste("SELECT COUNT(*) as count FROM", table_name, "WHERE station = '' OR station IS NULL"))
      validation_results <- paste(validation_results, "Records with empty station:", empty_check$count, "\n")
    }
    
    output$validation_results <- renderText(validation_results)
  })
  
  # Filter Controls
  output$filter_controls <- renderUI({
    table_name <- input$filter_table_select
    
    # Get column names for the selected table
    columns <- dbGetQuery(conn(), paste("PRAGMA table_info(", table_name, ")"))$name
    
    fluidRow(
      column(6,
        selectInput("filter_column", "Filter Column:", choices = columns)
      ),
      column(6,
        textInput("filter_value", "Filter Value:", placeholder = "Enter value to filter by")
      )
    )
  })
  
  # Filtered Table
  output$filtered_table <- DT::renderDataTable({
    table_name <- input$filter_table_select
    column <- input$filter_column
    value <- input$filter_value
    
    if (!is.null(column) && !is.null(value) && value != "") {
      query <- paste("SELECT * FROM", table_name, "WHERE", column, "LIKE '%", value, "%'")
    } else {
      query <- paste("SELECT * FROM", table_name)
    }
    
    data <- dbGetQuery(conn(), query)
    DT::datatable(data, options = list(pageLength = 25))
  })
  
  # Visualizations - Temporal Analysis
  # Export functionality
  observeEvent(input$export_data, {
    table_name <- input$export_table
    format <- input$export_format
    
    data <- dbGetQuery(conn(), paste("SELECT * FROM", table_name))
    
    if (format == "CSV") {
      filename <- paste0(table_name, "_export.csv")
      write.csv(data, filename, row.names = FALSE)
      output$export_status <- renderText(paste("Data exported to", filename))
    } else if (format == "Excel") {
      filename <- paste0(table_name, "_export.xlsx")
      writexl::write_xlsx(data, filename)
      output$export_status <- renderText(paste("Data exported to", filename))
    } else {
      filename <- paste0(table_name, "_export.json")
      jsonlite::write_json(data, filename)
      output$export_status <- renderText(paste("Data exported to", filename))
    }
  })

  # Network: information recorded about Men (Troops)

  # Network: information recorded about Women

  # =====================
  # Medicalization visuals (new)
  # =====================
  women_df <- reactive({
    dbGetQuery(conn(), "SELECT * FROM women_admission")
  })
  ops_df <- reactive({
    dbGetQuery(conn(), "SELECT rowid AS __rowid__, * FROM hospital_operations")
  })
  notes_df <- reactive({
    dbGetQuery(conn(), "SELECT * FROM hospital_notes")
  })
  troops_df <- reactive({
    dbGetQuery(conn(), "SELECT * FROM troops")
  })
  stations_df <- reactive({
    dbGetQuery(conn(), "SELECT * FROM stations")
  })

  # ---------------------
  # DS_Dataset ingestion (optional) and staff roles extraction
  # ---------------------
  .find_ds_dataset_file <- function() {
    candidates <- c(
      "DS_Dataset.xlsx",
      "content/DS_Dataset.xlsx",
      "data_raw/DS_Dataset.xlsx",
      "archive/DS_Dataset.xlsx",
      "archive/data_raw/DS_Dataset.xlsx"
    )
    existing <- candidates[file.exists(candidates)]
    if (length(existing) > 0) existing[[1]] else NULL
  }

  .normalize_station_key <- function(x) {
    tolower(trimws(as.character(x)))
  }

  # Version bump to re-trigger DS ingestion after upload
  ds_version <- reactiveVal(0)

  ds_dataset_clean <- reactive({
    ds_version()  # dependency to trigger reactivity
    path <- .find_ds_dataset_file()
    if (is.null(path)) return(data.frame())
    if (!requireNamespace("readxl", quietly = TRUE)) {
      message("DS_Dataset found at ", path, " but readxl is not installed; skipping ingestion.")
      return(data.frame())
    }
    # Read all sheets defensively
    sheets <- tryCatch(readxl::excel_sheets(path), error = function(e) character(0))
    if (length(sheets) == 0) return(data.frame())
    lst <- lapply(sheets, function(sh) {
      df <- tryCatch(suppressWarnings(readxl::read_excel(path, sheet = sh)), error = function(e) NULL)
      if (is.null(df) || nrow(df) == 0) return(NULL)
      df$.__sheet__ <- sh
      df
    })
    lst <- Filter(Negate(is.null), lst)
    if (length(lst) == 0) return(data.frame())
    df <- dplyr::bind_rows(lst)
    if (nrow(df) == 0) return(df)
    # Heuristic column harmonization
    names(df) <- tolower(gsub("[^a-z0-9]+", "_", names(df)))
    # Station
    station_col <- intersect(c("station","name","cantonment","station_name"), names(df))
    if (length(station_col) == 0) df$station <- NA_character_ else df$station <- df[[station_col[1]]]
    # Year
    if ("year" %in% names(df)) {
      year_raw <- df$year
    } else if ("date" %in% names(df)) {
      year_raw <- df$date
    } else {
      year_raw <- NA
    }
    df$year <- suppressWarnings(as.integer(stringr::str_extract(as.character(year_raw), "[0-9]{4}")))
    # Region/Country if present; otherwise try to enrich from stations
    if (!("region" %in% names(df))) df$region <- NA_character_
    if (!("country" %in% names(df))) df$country <- NA_character_
    # Join with stations to backfill region/country
    st <- stations_df()
    if (nrow(st) > 0) {
      st <- st %>% dplyr::mutate(station_key = .normalize_station_key(dplyr::coalesce(.data$name, .data$station))) %>%
        dplyr::select(station_key, region_st = .data$region, country_st = .data$country)
      df <- df %>%
        dplyr::mutate(station_key = .normalize_station_key(.data$station)) %>%
        dplyr::left_join(st, by = "station_key") %>%
        dplyr::mutate(
          region = dplyr::coalesce(.data$region, .data$region_st),
          country = dplyr::coalesce(.data$country, .data$country_st)
        ) %>%
        dplyr::select(-dplyr::any_of(c("region_st","country_st","station_key")))
    }
    # Build a text blob across all character columns (excluding obvious id fields)
    char_cols <- names(df)[vapply(df, is.character, logical(1))]
    exclude <- c("station","region","country","__sheet__")
    text_cols <- setdiff(char_cols, exclude)
    if (length(text_cols) == 0) {
      df$text_blob <- NA_character_
    } else {
      df$text_blob <- apply(df[text_cols], 1, function(row) {
        x <- paste(row, collapse = " ")
        x <- .clean_remarks(.strip_specials(x))
        tolower(ifelse(is.na(x), "", x))
      })
    }
    # Role dictionaries (expandable)
    male_roles <- c("surgeon","apothecary","doctor","medical officer","m\\.?o\\.?","secretary","dresser","compounder")
    female_roles <- c("matron","nurse","midwife","ayah")
    # Build regex
    male_rx <- paste0("\\b(", paste(male_roles, collapse = "|"), ")s?\\b")
    female_rx <- paste0("\\b(", paste(female_roles, collapse = "|"), ")s?\\b")
    neg_rx <- "\\b(no|without|vacant|lacking|not appointed)\\b.{0,20}"
    # Count mentions and negate obvious negations
    df$male_mentions_pos <- ifelse(is.na(df$text_blob), 0L, stringr::str_count(df$text_blob, regex(male_rx, ignore_case = TRUE)))
    df$female_mentions_pos <- ifelse(is.na(df$text_blob), 0L, stringr::str_count(df$text_blob, regex(female_rx, ignore_case = TRUE)))
    df$male_mentions_neg <- ifelse(is.na(df$text_blob), 0L, stringr::str_count(df$text_blob, regex(paste0(neg_rx, male_rx), ignore_case = TRUE)))
    df$female_mentions_neg <- ifelse(is.na(df$text_blob), 0L, stringr::str_count(df$text_blob, regex(paste0(neg_rx, female_rx), ignore_case = TRUE)))
    df$male_mentions <- pmax(0L, df$male_mentions_pos - df$male_mentions_neg)
    df$female_mentions <- pmax(0L, df$female_mentions_pos - df$female_mentions_neg)
    df$total_mentions <- df$male_mentions + df$female_mentions
    # Keep key fields for aggregation (retain text_blob for word cloud source)
    df %>% dplyr::select(station, region, country, year, male_mentions, female_mentions, total_mentions, text_blob, `__sheet__`)
  })

  # Prefer DB table if available; fall back to Excel-derived cleaned data
  ds_mentions_source <- reactive({
    con <- conn()
    tbl <- "ds_staff_mentions"
    if (DBI::dbExistsTable(con, tbl)) {
      out <- tryCatch(DBI::dbReadTable(con, tbl), error = function(e) NULL)
      if (!is.null(out) && nrow(out) > 0) return(out)
    }
    ds_dataset_clean()
  })

  # Status readout for DS dataset
  output$ds_dataset_status <- renderText({
    con <- conn(); tbl <- "ds_staff_mentions"; has_tbl <- DBI::dbExistsTable(con, tbl)
    path <- .find_ds_dataset_file(); has_file <- !is.null(path)
    src <- if (has_tbl) "DB table ds_staff_mentions" else if (has_file) basename(path) else "none"
    ds <- ds_mentions_source()
    if (nrow(ds) == 0) {
      return(paste0("DS source: ", src, ". No usable rows. Place DS_Dataset.xlsx in repo or save to DB."))
    }
    yr <- range(na.omit(ds$year)); yr_text <- if (all(is.infinite(yr))) "N/A" else paste(yr, collapse = "-")
    paste0(
      "DS source: ", src,
      " | Rows: ", nrow(ds),
      " | Years: ", yr_text,
      " | Regions: ", length(unique(na.omit(ds$region)))
    )
  })

  # Save cleaned DS dataset to SQLite
  observeEvent(input$ds_save_to_db, {
    ds <- ds_mentions_source()
    validate(need(nrow(ds) > 0, "No DS dataset rows to save"))
    tbl <- "ds_staff_mentions"
    con <- conn()
    try({
      if (DBI::dbExistsTable(con, tbl)) {
        # Replace with latest cleaned extract
        DBI::dbRemoveTable(con, tbl)
      }
      ds_to_save <- ds
      ds_to_save$created_at <- as.character(Sys.time())
      DBI::dbWriteTable(con, tbl, ds_to_save, overwrite = FALSE, append = FALSE)
    }, silent = TRUE)
    if (!DBI::dbExistsTable(con, tbl)) {
      output$ds_save_status <- renderText("Failed to save DS staff mentions to database.")
    } else {
      n <- DBI::dbGetQuery(con, paste0("SELECT COUNT(*) AS n FROM ", tbl))$n
      output$ds_save_status <- renderText(paste0("Saved ", n, " rows to table '", tbl, "'."))
    }
  })

  # Handle file upload: save as data_raw/DS_Dataset.xlsx, then re-ingest and auto-save to DB
  observeEvent(input$ds_upload, {
    files <- input$ds_upload
    req(files)
    dest_dir <- "data_raw"; if (!dir.exists(dest_dir)) dir.create(dest_dir, recursive = TRUE, showWarnings = FALSE)
    dest <- file.path(dest_dir, "DS_Dataset.xlsx")
    copied <- tryCatch(file.copy(files$datapath[1], dest, overwrite = TRUE), error = function(e) FALSE)
    if (!isTRUE(copied)) {
      output$ds_save_status <- renderText("Upload failed: could not save DS_Dataset.xlsx to data_raw/.")
      return()
    }
    # bump version to re-read
    ds_version(ds_version() + 1)
    # auto-save to DB
    isolate({
      ds <- ds_dataset_clean()
      if (nrow(ds) > 0) {
        tbl <- "ds_staff_mentions"; con <- conn()
        try({ if (DBI::dbExistsTable(con, tbl)) DBI::dbRemoveTable(con, tbl) }, silent = TRUE)
        ds$created_at <- as.character(Sys.time())
        ok <- tryCatch({ DBI::dbWriteTable(con, tbl, ds, overwrite = FALSE, append = FALSE); TRUE }, error = function(e) FALSE)
        if (ok) {
          n <- DBI::dbGetQuery(con, paste0("SELECT COUNT(*) AS n FROM ", tbl))$n
          output$ds_save_status <- renderText(paste0("Uploaded and saved ", n, " rows to '", tbl, "'."))
        } else {
          output$ds_save_status <- renderText("Uploaded file saved, but failed to write to DB.")
        }
      } else {
        output$ds_save_status <- renderText("Uploaded file saved, but no usable rows after cleaning.")
      }
    })
  })

  # Simple metrics summary to aid visibility
  output$ds_metrics_text <- renderUI({
    ds <- ds_mentions_source()
    if (nrow(ds) == 0) {
      return(HTML("<div style='color:#7f8c8d'>No staff mentions available yet. Upload DS_Dataset.xlsx or use the Save button if you have already ingested.</div>"))
    }
    tot_m <- sum(ds$male_mentions, na.rm = TRUE)
    tot_f <- sum(ds$female_mentions, na.rm = TRUE)
    yr <- range(na.omit(ds$year)); yr_text <- if (all(is.infinite(yr))) "N/A" else paste(yr, collapse = "-")
    
    # Identify missing years in the range
    years_present <- sort(unique(na.omit(ds$year)))
    missing_years_text <- ""
    if (length(years_present) > 1) {
      yr_min <- min(years_present)
      yr_max <- max(years_present)
      expected_years <- seq(yr_min, yr_max)
      missing_years <- setdiff(expected_years, years_present)
      if (length(missing_years) > 0) {
        missing_years_text <- paste0(
          " &nbsp; | &nbsp; <span style='color:#e74c3c'><b>Missing years</b>: ",
          paste(missing_years, collapse = ", "),
          "</span>"
        )
      }
    }
    
    HTML(paste0(
      "<div style='margin:8px 0; color:#2c3e50'>",
      "<b>Total mentions</b>: ", (tot_m + tot_f),
      " &nbsp; | &nbsp; <span style='color:#2c3e50'><b>Male</b>: ", tot_m, "</span>",
      " &nbsp; | &nbsp; <span style='color:#9b59b6'><b>Female</b>: ", tot_f, "</span>",
      " &nbsp; | &nbsp; <b>Years</b>: ", yr_text,
      missing_years_text,
      "</div>"
    ))
  })

  # ---------------------
  # Admissions by Region - controls
  # ---------------------
  observe({
    # Populate region choices from both datasets
    w <- women_df(); t <- troops_df()
    regions <- sort(unique(na.omit(c(w$region, t$region))))
    if (length(regions) > 0) {
      updateSelectizeInput(session, "admissions_regions", choices = regions, selected = regions, server = TRUE)
    }
  })

  # ---------------------
  # Hospital Notes helpers
  # ---------------------
  `%||%` <- function(a, b) {
    if (is.null(a) || length(a) == 0 || (length(a) == 1 && is.na(a))) b else a
  }

  # Utility to trim and normalize whitespace
  .trim_ws <- function(x) {
    if (is.null(x)) return(x)
    x <- gsub("\n|\r", " ", x)
    x <- gsub("[\t ]+", " ", x)
    x <- trimws(x)
    x[x == ""] <- NA_character_
    x
  }
  # Remove non-ASCII and special characters except a safe punctuation set
  .strip_specials <- function(x) {
    if (is.null(x)) return(x)
    x0 <- as.character(x)
    # Remove specific unwanted patterns like "Ae108:3'"AMadras 1-merged copy.pdf'"AL30-L32""A"e
    # This pattern appears in various forms, so we'll remove all variations
    x0 <- gsub('"*Ae\\d+:\\d+[\'"]+"A[^"]*\\.pdf[\'"]+"AL\\d+-L\\d+[\'"]+"A"e\\.?', '', x0)
    x0 <- gsub('Ae\\d+:\\d+[\'"]+"A[^"]*\\.pdf[\'"]+"AL\\d+-L\\d+[\'"]+"A"e\\.?', '', x0)
    # Remove any remaining variations with double quotes
    x0 <- gsub('"Ae\\d+:\\d+.*?\\.pdf.*?L\\d+"', '', x0)
    # Clean up multiple commas and periods
    x0 <- gsub('[.,]+\\s*[.,]+', '.', x0)
    x0 <- gsub('^[.,\\s]+', '', x0)
    x0 <- gsub('[.,\\s]+$', '', x0)
    # transliterate to ASCII and drop unconvertible
    x0 <- iconv(x0, to = "ASCII//TRANSLIT", sub = "")
  # keep letters, numbers, whitespace, and some common punctuation
  x0 <- gsub("[^A-Za-z0-9 \t\n\r.,;:!()'\"/?-]", "", x0)
    # collapse whitespace and trim
    x0 <- gsub("[\t ]+", " ", x0)
    x0 <- trimws(x0)
    x0[x0 == ""] <- NA_character_
    x0
  }
  # Normalize inspection regularity to categories
  .normalize_regularity <- function(x) {
    # sanitize first to strip odd characters, then normalize
    x0 <- tolower(.strip_specials(.trim_ws(as.character(x))))
    dplyr::case_when(
      is.na(x0) ~ NA_character_,
      grepl("regular|weekly|monthly|quarterly|monthly|periodic", x0) & !grepl("irregular|infrequent|rare|sporadic", x0) ~ "Regular",
      grepl("irregular|infrequent|rare|sporadic|occasional", x0) ~ "Irregular",
      TRUE ~ "Other"
    )
  }

  # Specialized cleaning for remarks: remove PDF artifact strings and boilerplate
  .clean_remarks <- function(x) {
    if (is.null(x)) return(x)
    x0 <- as.character(x)
    # Remove sequences like Ae108:3'"AMadras 1-merged copy.pdf'"AL22-L32""A"e (and variants)
    # Broad pattern: Ae<d>:<d> ... .pdf ... L<d>-L<d> ... A"e with optional quotes in-between
    x0 <- gsub('\"*Ae\\d+:\\d+[^\n]*?\\.pdf[^\n]*?L\\d+-L\\d+[^\n]*?A\"e\\.?', '', x0, perl = TRUE)
    # Run a second pass in case of multiple concatenated artifacts
    x0 <- gsub('\"*Ae\\d+:\\d+[^\n]*?\\.pdf[^\n]*?L\\d+-L\\d+[^\n]*?A\"e\\.?', '', x0, perl = TRUE)
    # Remove boilerplate like "No explicit 1883 detail visible in extract." (any year)
    x0 <- gsub('No explicit [0-9]{4} detail visible in extract\\.?', '', x0, ignore.case = TRUE)
    # Normalize whitespace and punctuation leftovers
    x0 <- gsub('[\t ]+', ' ', x0)
    x0 <- gsub('([,.;:])\1+', '\\1', x0, perl = TRUE)
    x0 <- gsub('^[,.;: ]+|[,.;: ]+$', '', x0)
    x0[x0 == ""] <- NA_character_
    x0
  }

  # Reactive cleaned Hospital Notes dataset
  hospital_notes_df <- reactive({
    # Load hospital_notes table directly (not joining with ops)
    nts <- notes_df()
    if (nrow(nts) == 0) return(data.frame(
      hid = character(0),
      doc_id = character(0),
      station = character(0),
      region = character(0),
      country = character(0),
      year = integer(0),
      ops_inspection_regularity = character(0),
      ops_unlicensed_control_notes = character(0),
      ops_committee_activity_notes = character(0),
      remarks = character(0)
    ))
    
    # Extract station and year from doc_id (e.g., "NWPO-1878" -> region "NWPO", year "1878")
    # If extracted_year exists, use that; otherwise try to parse from doc_id
    nts <- nts %>%
      dplyr::mutate(
        year = dplyr::coalesce(
          suppressWarnings(as.integer(extracted_year)),
          suppressWarnings(as.integer(stringr::str_extract(doc_id, "\\d{4}")))
        ),
        region_code = stringr::str_extract(doc_id, "^[A-Z]+"),
        station = NA_character_,  # We don't have station info in hospital_notes
        region = NA_character_,
        country = NA_character_
      )
    
    # Clean and normalize the notes fields
    nts %>%
      dplyr::select(
        hid,
        doc_id,
        station,
        region,
        country,
        year,
        ops_inspection_regularity,
        ops_unlicensed_control_notes,
        ops_committee_activity_notes,
        remarks
      ) %>%
      dplyr::mutate(
        ops_inspection_regularity = .normalize_regularity(ops_inspection_regularity),
        ops_unlicensed_control_notes = .strip_specials(ops_unlicensed_control_notes),
        ops_committee_activity_notes = .strip_specials(ops_committee_activity_notes),
        remarks = .clean_remarks(.strip_specials(remarks)),
        .key = hid,
        .key_col = "hid"
      )
  })

  # ---------------------
  # Story page: curated terms word cloud (Hospital Notes only)
  # ---------------------
  story_terms_counts <- reactive({
    hn <- hospital_notes_df()
    if (nrow(hn) == 0) {
      # Show all curated terms at equal weight if no notes are available
      return(data.frame(term = c(
        "clandestine women","unregistered women","registered women",
        "public/bazaar women","common prostitutes","registered prostitutes",
        "unregistered prostitutes","dancing/nautch girls","diseased women",
        "women examined","women detained","women imprisoned","women fined",
        "native women","european women","servants","ayahs"
      ), freq = 1L, stringsAsFactors = FALSE))
    }
    text <- paste(
      tolower(paste(na.omit(hn$ops_unlicensed_control_notes), collapse = " \n ")),
      tolower(paste(na.omit(hn$ops_committee_activity_notes), collapse = " \n ")),
      tolower(paste(na.omit(hn$remarks), collapse = " \n "))
    )
    txt <- .clean_remarks(.strip_specials(text))
    # Canonical labels -> regex (synonyms included)
    terms <- list(
      "clandestine women" = "\\bclandestine women\\b|\\bclandestine\\b",
      "unregistered women" = "\\bunregistered women\\b",
      "registered women" = "\\bregistered women\\b",
      "public/bazaar women" = "\\bpublic women\\b|\\bwomen of the town\\b|\\bbazaar women\\b",
      "registered prostitutes" = "\\bregistered prostitutes?\\b",
      "unregistered prostitutes" = "\\bunregistered prostitutes?\\b",
      "common prostitutes" = "\\bcommon prostitutes?\\b",
      "dancing/nautch girls" = "\\bdancing girls\\b|\\bnautch girls\\b",
      "diseased women" = "\\bdiseased women\\b",
      "women examined" = "\\bwomen examined\\b",
      "women detained" = "\\bwomen detained\\b",
      "women imprisoned" = "\\bwomen imprisoned\\b",
      "women fined" = "\\bwomen fined\\b",
      "native women" = "\\bnative women\\b",
      "european women" = "\\beuropean women\\b",
      "servants" = "\\bservants?\\b",
      "ayahs" = "\\bayahs?\\b|\\bayah\\b"
    )
    df <- lapply(names(terms), function(lbl) {
      rx <- terms[[lbl]]
      n <- if (is.null(txt) || is.na(txt) || nchar(txt) == 0) 0L else stringr::str_count(txt, regex(rx, ignore_case = TRUE))
      data.frame(term = lbl, freq = as.integer(n), stringsAsFactors = FALSE)
    }) %>% dplyr::bind_rows()
    df$freq[is.na(df$freq)] <- 0L
    # Ensure every curated term is visible at least minimally
    df$freq <- pmax(1L, df$freq)
    df
  })

  output$story_terms_viz <- renderUI({
    if (requireNamespace("wordcloud2", quietly = TRUE)) {
      # Use dynamic function call to avoid loading wordcloud2 namespace at server init
      wc2_output <- get("wordcloud2Output", envir = asNamespace("wordcloud2"))
      wc2_output("story_terms_wordcloud", height = 560)
    } else {
      plotlyOutput("story_terms_bar", height = 560)
    }
  })

  # Wordcloud renderer (when available) - conditionally define
  observe({
    if (requireNamespace("wordcloud2", quietly = TRUE)) {
      wc2_render <- get("renderWordcloud2", envir = asNamespace("wordcloud2"))
      wc2_fn <- get("wordcloud2", envir = asNamespace("wordcloud2"))
      output$story_terms_wordcloud <- wc2_render({
        tryCatch({
          df <- story_terms_counts()
          if (nrow(df) == 0) df <- data.frame(term = c('no','terms','found'), freq = c(3,2,1))
          wc2_fn(data.frame(word = df$term, freq = df$freq), size = 2.2)
        }, error = function(e) {
          NULL
        })
      })
    }
  })

  output$story_terms_bar <- renderPlotly({
    df <- story_terms_counts() %>% dplyr::arrange(dplyr::desc(freq))
    plot_ly(df, x = ~freq, y = ~reorder(term, freq), type = 'bar', orientation = 'h', marker = list(color = '#6c5ce7')) %>%
      layout(title = 'Terminology Mentions', xaxis = list(title = 'Count'), yaxis = list(title = 'Term'))
  })

  # Archive Images Gallery with Navigation
  output$overview_images <- renderUI({
    img_dir <- "content/images_safe"
    message("Rendering overview_images UI")
    
    if (!dir.exists(img_dir)) {
      message("Images directory not found")
      return(p("No images directory found. Create 'content/images/' to add archive materials.", 
               style = "color: #95a5a6; font-style: italic;"))
    }
    
    # Get all image files
    img_files <- list.files(img_dir, pattern = "\\.(jpg|jpeg|png|gif|webp)$", 
                           ignore.case = TRUE, full.names = FALSE)
    
    message(sprintf("Found %d image files", length(img_files)))
    
    if (length(img_files) == 0) {
      return(p("No images found. Upload images or place them in 'content/images/'.", 
               style = "color: #95a5a6; font-style: italic;"))
    }
    
    # Current image index (use reactiveVal current_image_index)
    current_idx <- current_image_index()
    if (current_idx > length(img_files)) current_idx <- 1
    
    message(sprintf("Current image index: %d", current_idx))
    
    # Current image
    current_img <- img_files[current_idx]
    img_path <- file.path(img_dir, current_img)
    
    # Image descriptions
    descriptions <- list(
      "act_xxvi_1868_lock_hospitals" = "Act No. XXVI of 1868: Legislation enabling municipalities to provide for Lock-Hospitals. This act expanded the state's power to establish and maintain lock hospitals for the prevention of contagious venereal disease.",
      "lock_hospitals_receipts_1873" = "Statement No. III showing the receipts and expenditure on account of Lock Hospitals during the year 1873, documenting the financial administration of the surveillance system across different stations.",
      "bassein_hospital_records_1875" = "Amended Annual Statement from the Lock-hospital at Bassein (1875) showing detailed records of registered women, diseases diagnosed, and monthly statistics - a stark example of how women's bodies were transformed into administrative data.",
      "lock_hospital_buildings" = "Architectural renderings of Lock Hospital buildings, showing the physical infrastructure of medical surveillance. These institutions combined medical care with mechanisms of control and containment."
    )
    
    img_name <- gsub("\\.(jpg|jpeg|png|gif|webp)$", "", current_img, ignore.case = TRUE)
    img_description <- descriptions[[img_name]] %||% img_name
    
  # Create navigation UI
  # URL-encode filename to build a safe src for the <img> tag
  safe_src <- sprintf("images/%s", utils::URLencode(current_img, reserved = TRUE))

  div(
      style = "max-width: 800px; margin: 0 auto; text-align: center;",
      # Image counter
      div(
        style = "margin-bottom: 15px; font-size: 14px; color: #7f8c8d;",
        sprintf("Image %d of %d", current_idx, length(img_files))
      ),
      # Image container with navigation
      div(
        style = "position: relative; margin: 20px 0; background: #fff; padding: 60px 20px 20px 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);",
        # Navigation buttons row at top
        div(
          style = "position: absolute; top: 15px; left: 50%; transform: translateX(-50%); z-index: 2; display: flex; gap: 15px;",
          actionButton(
            inputId = "prev_image",
            label = HTML("&#9664; Previous"),
            style = "background: #3498db; color: white; border: none; border-radius: 4px; padding: 8px 16px; font-size: 14px;"
          ),
          actionButton(
            inputId = "next_image",
            label = HTML("Next &#9654;"),
            style = "background: #3498db; color: white; border: none; border-radius: 4px; padding: 8px 16px; font-size: 14px;"
          )
        ),
        # Main image (use web-accessible path)
        tags$img(
          src = safe_src,
          style = "max-width: 100%; height: auto; border-radius: 4px; cursor: zoom-in;",
          onclick = sprintf("window.open('%s', '_blank')", safe_src),
          alt = img_name
        )
      ),
      # Image caption with description
      div(
        style = "margin-top: 15px; padding: 20px; background: #f8f9fa; border-radius: 4px;",
        h4(tools::toTitleCase(gsub("_", " ", img_name)), 
           style = "margin: 0 0 10px 0; color: #2c3e50; font-size: 18px; font-weight: 600;"),
        p(img_description,
          style = "margin: 0; color: #34495e; font-size: 14px; line-height: 1.6;")
      )
    )
  })


  # Dynamic filter controls for Hospital Notes
  output$hn_station_select <- renderUI({
    df <- hospital_notes_df()
    stations <- sort(unique(na.omit(df$station)))
    selectInput("hn_station", "Station:", choices = c("All", stations), selected = "All")
  })
  output$hn_year_range <- renderUI({
    df <- hospital_notes_df()
    yr <- sort(unique(na.omit(as.integer(df$year))))
    if (length(yr) == 0) yr <- c(NA_integer_, NA_integer_)
    sliderInput("hn_year", "Year Range:", min = min(yr, na.rm = TRUE), max = max(yr, na.rm = TRUE), value = c(min(yr, na.rm = TRUE), max(yr, na.rm = TRUE)), sep = "")
  })

  # Update Country choices based on data
  observe({
    df <- hospital_notes_df()
    countries <- sort(unique(na.omit(df$country)))
    updateSelectInput(session, "hn_country", choices = c("All", countries), selected = "All")
  })

  # Filtered dataset for display/export
  hospital_notes_filtered <- reactive({
    df <- hospital_notes_df()
    if (nrow(df) == 0) return(df)
    # Apply filters
    if (!is.null(input$hn_station) && input$hn_station != "All") df <- df %>% dplyr::filter(.data$station == input$hn_station)
    if (!is.null(input$hn_country) && input$hn_country != "All") df <- df %>% dplyr::filter(.data$country == input$hn_country)
    if (!is.null(input$hn_year) && length(input$hn_year) == 2 && all(!is.na(input$hn_year))) {
      df <- df %>% dplyr::filter(dplyr::between(as.integer(.data$year), input$hn_year[1], input$hn_year[2]))
    }
    if (!is.null(input$hn_search) && nzchar(input$hn_search)) {
      kw <- tolower(input$hn_search)
      keep <- grepl(kw, tolower(paste(df$ops_unlicensed_control_notes, df$ops_committee_activity_notes, df$remarks)), fixed = TRUE)
      df <- df[keep, , drop = FALSE]
    }
    df
  })

  # Render table
  output$hospital_notes_table <- DT::renderDataTable({
    df <- hospital_notes_filtered()
    validate(need(nrow(df) > 0, "No hospital notes data available for current filters"))
    # Column order for display
    display_cols <- c(
      "station","region","country","year",
      "ops_inspection_regularity","ops_unlicensed_control_notes","ops_committee_activity_notes","remarks" # nolint
    )
    missing <- setdiff(display_cols, names(df))
    for (m in missing) df[[m]] <- NA
    df <- df[, display_cols]
    DT::datatable(df, options = list(pageLength = 25, scrollX = TRUE, dom = 'Bfrtip', buttons = c('copy','csv','excel','print')), extensions = 'Buttons')
  })

  # Download cleaned notes
  output$download_hospital_notes <- downloadHandler(
    filename = function() paste0("hospital_notes_cleaned_", Sys.Date(), ".csv"),
    content = function(file) {
      df <- hospital_notes_filtered()
      write.csv(df, file, row.names = FALSE)
    }
  )

  # Persist cleaned notes back to the database (new)
  observeEvent(input$hn_save_to_db, {
    df <- hospital_notes_df()
    if (nrow(df) == 0) {
      output$hn_save_status <- renderText("No hospital operations data to save.")
      return()
    }
    # Identify key column name used for updates
    key_name <- unique(df$.key_col)[1]
    if (is.null(key_name) || is.na(key_name)) key_name <- "__rowid__"
    where_col <- if (identical(key_name, "__rowid__")) "rowid" else key_name

    # Ensure destination columns exist
    con <- conn()
    add_col <- function(sql) { tryCatch({ DBI::dbExecute(con, sql) }, error = function(e) {}) }
    add_col("ALTER TABLE hospital_operations ADD COLUMN ops_unlicensed_control_notes_clean TEXT")
    add_col("ALTER TABLE hospital_operations ADD COLUMN ops_committee_activity_notes_clean TEXT")
    add_col("ALTER TABLE hospital_operations ADD COLUMN remarks_clean TEXT")
    add_col("ALTER TABLE hospital_operations ADD COLUMN ops_inspection_regularity_norm TEXT")

    # Prepare update statement
    sql <- paste0(
      "UPDATE hospital_operations SET ",
      "ops_unlicensed_control_notes_clean = ?, ",
      "ops_committee_activity_notes_clean = ?, ",
      "remarks_clean = ?, ",
      "ops_inspection_regularity_norm = ? ",
      "WHERE ", where_col, " = ?"
    )

    # Execute updates in a transaction
    updated <- 0L
    DBI::dbBegin(con)
    err <- NULL
    for (i in seq_len(nrow(df))) {
      key_val <- df$.key[i]
      if (is.na(key_val)) next
      params <- list(
        df$ops_unlicensed_control_notes[i],
        df$ops_committee_activity_notes[i],
        df$remarks[i],
        df$ops_inspection_regularity[i],
        key_val
      )
      tryCatch({
        DBI::dbExecute(con, sql, params = params)
        updated <- updated + 1L
      }, error = function(e) {
        err <<- e$message
      })
      if (!is.null(err)) break
    }
    if (is.null(err)) {
      tryCatch(DBI::dbCommit(con), error = function(e) { err <<- e$message; DBI::dbRollback(con) })
    } else {
      DBI::dbRollback(con)
    }
    if (is.null(err)) {
      output$hn_save_status <- renderText(paste0("Saved cleaned fields to database for ", updated, " rows using key column '", where_col, "'."))
    } else {
      output$hn_save_status <- renderText(paste0("Error during save: ", err))
    }
  })


  # Temporal

  # Geography

  # Disease

  # Punitive
  # Military-Medical: Interactive Surveillance Pipeline (Sankey diagram)

  # Acts
  output$med_acts_by_station <- DT::renderDataTable({
    df <- dbGetQuery(conn(), "
      SELECT station, act, COUNT(*) as count
      FROM hospital_operations
      WHERE act IS NOT NULL AND act != 'None' AND station IS NOT NULL
      GROUP BY station, act
      ORDER BY count DESC
    ")
    DT::datatable(df, options = list(pageLength = 10, scrollX = TRUE))
  })
  
  # Acts Animated Map
  
  # Populate Act filter choices dynamically
  observe({
    acts_list <- dbGetQuery(conn(), "
      SELECT DISTINCT act
      FROM hospital_operations
      WHERE act IS NOT NULL AND act != 'None' AND TRIM(act) != ''
      ORDER BY act
    ")
    
    if (nrow(acts_list) > 0) {
      choices <- c("All Acts" = "all", setNames(acts_list$act, acts_list$act))
      updateSelectInput(session, "network_act_filter", choices = choices)
    }
  })
  
  # Acts Year Summary

  # Summary

  # Stations Map
  output$stations_map <- renderLeaflet({
    st <- stations_df()
    message('renderLeaflet: stations_map - stations rows = ', nrow(st))
    validate(need(nrow(st) > 0, "No stations data found"))
    # Try to detect lat/lon column names
    lat_col <- NA; lon_col <- NA
    if (all(c('lat','lon') %in% names(st))) { lat_col <- 'lat'; lon_col <- 'lon' }
    if (all(c('lat','lng') %in% names(st))) { lat_col <- 'lat'; lon_col <- 'lng' }
    if (all(c('latitude','longitude') %in% names(st))) { lat_col <- 'latitude'; lon_col <- 'longitude' }
    validate(need(!is.na(lat_col) && !is.na(lon_col), "Stations are missing latitude/longitude columns"))
    st2 <- st %>% dplyr::filter(!is.na(.data[[lat_col]]), !is.na(.data[[lon_col]])) %>%
      dplyr::mutate(lat = as.numeric(.data[[lat_col]]), lon = as.numeric(.data[[lon_col]])) %>%
      dplyr::filter(lat <= 90, lat >= -90, lon <= 180, lon >= -180)
    # Robust popup label
    if ("name" %in% names(st2)) {
      st2$label_name <- st2$name
    } else if ("station" %in% names(st2)) {
      st2$label_name <- st2$station
    } else {
      st2$label_name <- "Station"
    }
    validate(need(nrow(st2) > 0, "No valid geolocated stations to display"))
    message('renderLeaflet: stations_map - geolocated rows = ', nrow(st2))
    leaflet(st2) %>% addTiles() %>%
      addCircleMarkers(~lon, ~lat, radius = 5, color = "#2c7fb8", fillOpacity = 0.7,
        popup = ~paste0("<b>", label_name, "</b><br>Region: ", region, "<br>Country: ", country))
  })
  
  # ---------------------
  # Temporal-Spatial Correlation Outputs
  # ---------------------
  # ---------------------

  
  # =====================
  # Story Tab Visualizations
  # =====================
  # Initialize story map once (base map + legend)
  output$story_map_overview <- renderLeaflet({
    leaflet() %>%
      addTiles() %>%
      setView(lng = 78.9629, lat = 20.5937, zoom = 5) %>%
      addLegend(
        position = "bottomright",
        colors = c("#e74c3c", "#3498db", "#9b59b6", "#f39c12", "#27ae60", "#95a5a6"),
        labels = c("Act XXII of 1864", "Act XIV of 1868", "Act III of 1880", "Act 1889", "Voluntary", "No Act"),
        title = "Contagious Diseases Acts",
        opacity = 0.8
      )
  })
  
  # Update markers when Act filter changes (without re-rendering entire map)
  observe({
    st <- stations_df()
    ops <- ops_df()
    req(nrow(st) > 0)
    
    # Get selected Acts from filter (default to all if none selected)
    selected_acts <- input$story_map_acts_filter
    if (is.null(selected_acts) || length(selected_acts) == 0) {
      selected_acts <- c("1864", "1868", "1880", "1889", "voluntary", "none")
    }
    
    # Join stations with hospital operations to get Acts
    # Get all unique station-act combinations
    station_acts <- ops %>%
      dplyr::select(station, act) %>%
      dplyr::distinct() %>%
      dplyr::mutate(
        act_category = dplyr::case_when(
          is.na(act) | act == "" | act == "None" ~ "none",
          grepl("1864|XXII", act, ignore.case = TRUE) ~ "1864",
          grepl("1868|XIV", act, ignore.case = TRUE) ~ "1868",
          grepl("1880|III", act, ignore.case = TRUE) ~ "1880",
          grepl("1889", act, ignore.case = TRUE) ~ "1889",
          grepl("voluntary|volunt", act, ignore.case = TRUE) ~ "voluntary",
          TRUE ~ "none"
        )
      ) %>%
      dplyr::filter(act_category %in% selected_acts) %>%
      dplyr::distinct(station, .keep_all = TRUE)
    
    # Filter stations to only those with matching Acts
    st_filtered <- st %>%
      dplyr::inner_join(station_acts, by = c("name" = "station"))
    
    # If no stations match, show all stations in grey
    if (nrow(st_filtered) == 0) {
      st_filtered <- st %>%
        dplyr::mutate(act = "No matching Acts", act_category = "none")
    }
    
    lat_col <- 'latitude'; lon_col <- 'longitude'
    if (all(c('lat','lon') %in% names(st_filtered))) { lat_col <- 'lat'; lon_col <- 'lon' }
    
    st2 <- st_filtered %>%
      dplyr::filter(!is.na(.data[[lat_col]]), !is.na(.data[[lon_col]])) %>%
      dplyr::mutate(
        lat = as.numeric(.data[[lat_col]]), 
        lon = as.numeric(.data[[lon_col]]),
        marker_color = dplyr::case_when(
          act_category == "1864" ~ "#e74c3c",
          act_category == "1868" ~ "#3498db",
          act_category == "1880" ~ "#9b59b6",
          act_category == "1889" ~ "#f39c12",
          act_category == "voluntary" ~ "#27ae60",
          TRUE ~ "#95a5a6"
        )
      )
    
    # Use leafletProxy to update only the markers without re-rendering the map
    leafletProxy("story_map_overview", data = st2) %>%
      clearMarkers() %>%
      addCircleMarkers(
        ~lon, ~lat,
        radius = 6,
        color = ~marker_color,
        fillColor = ~marker_color,
        fillOpacity = 0.7,
        stroke = TRUE,
        weight = 1,
        popup = ~paste0("<b>", name, "</b><br>Region: ", region, "<br>Act: ", ifelse(is.na(act) | act == "", "None", act))
      )
  })
  
  # Story: Acts timeline
  output$story_acts_timeline <- renderUI({
    HTML("
      <div style='padding: 20px;'>
        <!-- Horizontal timeline container -->
        <div style='display: flex; gap: 20px; overflow-x: auto; padding-bottom: 20px;'>
          
          <!-- 1864 Act -->
          <div style='min-width: 300px; flex: 1; padding: 20px; background: rgba(231, 76, 60, 0.05); border-top: 4px solid #e74c3c; border-radius: 4px;'>
            <div style='font-size: 1.4em; font-weight: bold; color: #e74c3c; margin-bottom: 10px;'>1864</div>
            <div style='font-size: 1.1em; font-weight: 600; color: #2c3e50; margin-bottom: 12px;'>Cantonments Act XXII</div>
            <div style='font-size: 0.9em; color: #34495e; line-height: 1.6;'>
              <strong style='color: #e74c3c;'>\"For protection of the health of the troops\"</strong>
              <br><br>
              The first formal attempt to translate moral and medical anxieties into legal regulation. Granted local governments power to make rules \"for inspecting and controlling houses of ill-fame.\" Powers could be \"extended beyond the limits of Cantonments.\"
              <br><br>
              Though framed as sanitary, this language was fundamentally disciplinary—justifying military authority's intrusion into civilian space.
            </div>
          </div>
          
          <!-- 1868 Act -->
          <div style='min-width: 300px; flex: 1; padding: 20px; background: rgba(52, 152, 219, 0.05); border-top: 4px solid #3498db; border-radius: 4px;'>
            <div style='font-size: 1.4em; font-weight: bold; color: #3498db; margin-bottom: 10px;'>1868</div>
            <div style='font-size: 1.1em; font-weight: 600; color: #2c3e50; margin-bottom: 12px;'>Contagious Diseases Act XIV</div>
            <div style='font-size: 0.9em; color: #34495e; line-height: 1.6;'>
              <strong style='color: #3498db;'>Creating the Administrative Category</strong>
              <br><br>
              Codified the regime through official legislation. Required women to register: \"no woman shall carry on the business of a common prostitute...without being registered under this Act.\"
              <br><br>
              The law created an administrative category—\"prostitute\" became a bureaucratic identity produced through registration and inspection. Women faced \"periodical medical examination\"; failure meant fines, imprisonment, or forced confinement in certified hospitals.
            </div>
          </div>
          
          <!-- 1880 Act -->
          <div style='min-width: 300px; flex: 1; padding: 20px; background: rgba(155, 89, 182, 0.05); border-top: 4px solid #9b59b6; border-radius: 4px;'>
            <div style='font-size: 1.4em; font-weight: bold; color: #9b59b6; margin-bottom: 10px;'>1880</div>
            <div style='font-size: 1.1em; font-weight: 600; color: #2c3e50; margin-bottom: 12px;'>Cantonment Act III</div>
            <div style='font-size: 0.9em; color: #34495e; line-height: 1.6;'>
              <strong style='color: #9b59b6;'>\"Voluntary\" Compliance</strong>
              <br><br>
              Introduced after British repeal campaigns exposed moral tensions of compulsory examination. Softened language—women \"attend voluntarily\"—yet registration, detention, and medical authority remained unchanged.
              <br><br>
              \"Station\" replaced \"cantonment\", expanding Acts to ports, trading centres, and railway towns. What appeared as liberalization was actually expansion—surveillance under the guise of reform.
            </div>
          </div>
          
          <!-- 1889 Act -->
          <div style='min-width: 300px; flex: 1; padding: 20px; background: rgba(243, 156, 18, 0.05); border-top: 4px solid #f39c12; border-radius: 4px;'>
            <div style='font-size: 1.4em; font-weight: bold; color: #f39c12; margin-bottom: 10px;'>1889</div>
            <div style='font-size: 1.1em; font-weight: 600; color: #2c3e50; margin-bottom: 12px;'>Cantonment Act</div>
            <div style='font-size: 0.9em; color: #34495e; line-height: 1.6;'>
              Consolidated and refined earlier legislation, strengthening cantonment administration while maintaining medical surveillance.
              <br><br>
              By this point, the lock hospital had become a permanent feature of colonial governance—a network transforming women's bodies into bureaucratic evidence of disease and disorder.
            </div>
          </div>
          
        </div>
      </div>
    ")
  })
  
  # Handle "Explore Data" button click
  observeEvent(input$switch_to_tables, {
    updateTabItems(session, "sidebar", "tables")
  })
  
  # =====================
  # End Story Tab
  # =====================
  
  
  
  
  # =====================
  # Hospital Operations Visualizations
  # =====================
  
  # Debug info
  
  # Inspection Frequency Timeline
  
  # Inspection Frequency by Region
  
  # Unlicensed Control Methods Distribution
  
  # Unlicensed Control by Act
  
  # Committee Oversight Distribution
  
  # Committee Oversight by Region
  
  # Punishment Timeline (Absentees Punished)
  
  # Punishment by Station (Top 15)
  
  # (Removed) Administrative Intensity Map and status outputs at user's request

  # Staff role mentions (proxy) over time - simplified to use hospital ops directly

  # Staff role mentions by region - simplified to use hospital ops directly
  
  observeEvent(input$export_query, {
    query <- input$custom_query
    
    if (query != "") {
      tryCatch({
        data <- dbGetQuery(conn(), query)
        filename <- paste0("custom_query_export_", Sys.Date(), ".csv")
        write.csv(data, filename, row.names = FALSE)
        output$export_status <- renderText(paste("Query results exported to", filename))
      }, error = function(e) {
        output$export_status <- renderText(paste("Error executing query:", e$message))
      })
    } else {
      output$export_status <- renderText("Please enter a SQL query")
    }
  })
}

# Run the application
shinyApp(ui = ui, server = server)
